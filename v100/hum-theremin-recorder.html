<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>AERIAL v10.0 — Player (v100 patched)</title>
<link rel="manifest" href="./manifest.json?v=100"/>
<link rel="icon" href="../icon-192.png" sizes="192x192"/>
<style>
  :root{--bg:#0e0f12;--fg:#e6e6e6;--muted:#8a8f98}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,'Noto Sans JP',sans-serif}
  main{max-width:980px;margin:0 auto;padding:14px}
  .card{background:#12151b;border:1px solid #1f242c;border-radius:12px;padding:12px;margin:12px 0}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button,input,select{background:#0f1320;color:#cfe7ff;border:1px solid #253043;border-radius:8px;padding:8px 10px}
  .muted{color:var(--muted);font-size:13px}
  #burst{position:fixed;inset:0;pointer-events:none;z-index:5}
  #unlock{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);backdrop-filter:blur(3px);z-index:10}
  #unlock.hide{display:none}
  #bigStart{font-size:18px;padding:14px 22px}
</style>
</head><body>
<main>
  <section class="card">
    <h1 style="margin:0 0 8px">AERIAL v10.0 — Player（v100 パッチ）</h1>
    <div class="row">
      <label>Master</label><input id="master" type="range" min="0" max="100" value="80"/>
      <label>Theremin</label><input id="thgain" type="range" min="0" max="100" value="70"/>
      <label>BGM</label>
      <select id="bgmMode">
        <option value="auto">SonicWeather</option>
        <option value="file">ファイル</option>
        <option value="off">オフ</option>
      </select>
      <input id="bgmFile" type="file" accept="audio/*" style="display:none"/>
      <button id="btnPause">⏸ Pause</button>
      <button id="bigStart">▶ 音を有効化</button>
    </div>

    <div class="row" style="margin-top:8px">
      <strong>録音:</strong>
      <button id="recStartBtn">● Start</button>
      <button id="recStopBtn" disabled>■ Stop &amp; Save</button>
      <span id="recStatus" class="muted">Idle</span>
    </div>

    <div class="row" id="debugRow" style="margin-top:8px">
      <span class="muted">Audio: <span id="dbgState">idle</span></span>
      <span class="muted" style="margin-left:10px">SR: <span id="dbgSR">-</span></span>
      <span class="muted" style="margin-left:10px">t: <span id="dbgT">-</span></span>
      <button id="forceUnlock" style="margin-left:10px">▶ Force Unlock</button>
    </div>

    <p class="muted">タップで開始。傾きでTheremin（正弦波）、強く振るとチャイム。録音は Start→Stop でWAV保存。</p>
  </section>
</main>
<canvas id="burst"></canvas>
<div id="unlock"><div>
  <p style="margin:0 0 8px">タップして開始</p>
  <button id="btnUnlock">▶ Tap to Start</button>
</div></div>
<script>
let audioCtx=null, masterG, limiter;
let padNodes=[], padGain, filter, lfo, lfoGain, noiseSrc, noiseGain;
let therOsc, therGain;
let bgmEl=null, bgmSrc=null, bgmGain=null;
let chimeBuf=null, chimeGain;
let recNode=null, recording=false, recBuffers=[], recSampleRate=48000;

const masterEl=document.getElementById('master'), thgainEl=document.getElementById('thgain');
const bgmMode=document.getElementById('bgmMode'), bgmFile=document.getElementById('bgmFile');
const btnPause=document.getElementById('btnPause');
const overlay=document.getElementById('unlock'), btnUnlock=document.getElementById('btnUnlock'), btnBigStart=document.getElementById('bigStart');
const recStartBtn=document.getElementById('recStartBtn'), recStopBtn=document.getElementById('recStopBtn'), recStatus=document.getElementById('recStatus');

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function pickBaseHzByHour(){const h=new Date().getHours(); if(h>=5&&h<11)return 196; if(h>=11&&h<17)return 220; if(h>=17&&h<22)return 174.61; return 155.56;}
function makeImpulseResponse(ctx,duration=2.6,decay=5.5,reverse=false){const rate=ctx.sampleRate,length=Math.floor(rate*duration);const imp=ctx.createBuffer(2,length,rate);for(let ch=0;ch<2;ch++){const data=imp.getChannelData(ch);for(let i=0;i<length;i++){const t=reverse?(length-i):i;data[i]=(Math.random()*2-1)*Math.pow(1-i/length,decay);}}return imp;}

function concatFloat32(arrs){let n=0;for(const a of arrs){n+=a.length;}const out=new Float32Array(n);let o=0;for(const a of arrs){out.set(a,o);o+=a.length;}return out;}
function f32ToPCM16(f32){const dv=new DataView(new ArrayBuffer(f32.length*2));for(let i=0;i<f32.length;i++){let s=Math.max(-1,Math.min(1,f32[i]));dv.setInt16(i*2,s<0? s*0x8000 : s*0x7FFF,true);}return dv;}
function muxWAV(pcm16,sr){const buf=new ArrayBuffer(44+pcm16.byteLength);const v=new DataView(buf);function ws(o,s){for(let i=0;i<s.length;i++)v.setUint8(o+i,s.charCodeAt(i));}ws(0,'RIFF');v.setUint32(4,36+pcm16.byteLength,true);ws(8,'WAVE');ws(12,'fmt ');v.setUint32(16,16,true);v.setUint16(20,1,true);v.setUint16(22,1,true);v.setUint32(24,sr,true);v.setUint32(28,sr*2,true);v.setUint16(32,2,true);v.setUint16(34,16,true);ws(36,'data');v.setUint32(40,pcm16.byteLength,true);return new Blob([v,pcm16],{type:'audio/wav'});}

async function initRecorderTap(ctx, sourceNode){
  if(!ctx || !sourceNode) return;
  if(ctx.audioWorklet && ctx.audioWorklet._addedMixTap) return;
  const code=`class MixTap extends AudioWorkletProcessor{ process(inputs){ const ch=inputs[0]?.[0]; if(ch){ this.port.postMessage(ch.slice(0)); } return true; } } registerProcessor('mix-tap', MixTap);`;
  const blob=new Blob([code],{type:'application/javascript'});
  const url=URL.createObjectURL(blob);
  await ctx.audioWorklet.addModule(url);
  ctx.audioWorklet._addedMixTap=true;
  recNode=new AudioWorkletNode(ctx,'mix-tap');
  const tapGain=ctx.createGain(); tapGain.gain.value=1.0;
  sourceNode.connect(tapGain).connect(recNode);
  const silent=ctx.createGain(); silent.gain.value=0.0; recNode.connect(silent).connect(ctx.destination);
  recNode.port.onmessage=(e)=>{ if(recording){ recBuffers.push(new Float32Array(e.data)); } };
}

async function setup(){
  if(audioCtx) return;
  audioCtx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
  recSampleRate=audioCtx.sampleRate;

  masterG=audioCtx.createGain(); masterG.gain.value=parseInt(masterEl.value,10)/100;
  limiter=audioCtx.createDynamicsCompressor();
  limiter.threshold.value=-8; limiter.knee.value=12; limiter.ratio.value=12; limiter.attack.value=0.003; limiter.release.value=0.25;
  masterG.connect(limiter).connect(audioCtx.destination);

  const reverb=audioCtx.createConvolver(); reverb.buffer=makeImpulseResponse(audioCtx,2.6,5.5,true);
  const revOut=audioCtx.createGain(); revOut.gain.value=0.25; reverb.connect(revOut).connect(masterG);
  filter=audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=800;
  padGain=audioCtx.createGain(); padGain.gain.value=0.22; padGain.connect(filter); filter.connect(reverb); filter.connect(masterG);
  lfo=audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.09; lfoGain=audioCtx.createGain(); lfoGain.gain.value=200; lfo.connect(lfoGain); lfoGain.connect(filter.frequency); lfo.start();
  const base=pickBaseHzByHour(); const ratios=[1,5/4,3/2,2];
  for(let r of ratios){ const o=audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.value=base*r*(1+(Math.random()-0.5)*0.01);
    const vib=audioCtx.createOscillator(); vib.type='sine'; vib.frequency.value=0.12+Math.random()*0.12; const vg=audioCtx.createGain(); vg.gain.value=1.2+Math.random()*0.8; vib.connect(vg).connect(o.frequency); vib.start();
    const g=audioCtx.createGain(); g.gain.value=0.09; o.connect(g); g.connect(padGain); o.start(); padNodes.push(o,vib,g); }

  const noiseBuf=audioCtx.createBuffer(1, audioCtx.sampleRate*4, audioCtx.sampleRate);
  const ch=noiseBuf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*0.9;
  noiseSrc=audioCtx.createBufferSource(); noiseSrc.buffer=noiseBuf; noiseSrc.loop=true;
  const nFilter=audioCtx.createBiquadFilter(); nFilter.type='highpass'; nFilter.frequency.value=500;
  noiseGain=audioCtx.createGain(); noiseGain.gain.value=0.0;
  noiseSrc.connect(nFilter).connect(noiseGain).connect(revOut); noiseSrc.start();

  // Theremin
  therOsc=audioCtx.createOscillator(); therOsc.type='sine';
  therGain=audioCtx.createGain(); therGain.gain.value=parseInt(thgainEl.value,10)/100*0.08;
  therOsc.connect(therGain).connect(masterG); therOsc.start();

  // Chime from parent folder
  try{ const r=await fetch('../Chime.mp3'); const ab=await r.arrayBuffer(); chimeBuf=await audioCtx.decodeAudioData(ab);}catch(e){ console.warn('Chime load failed', e); }
  chimeGain=audioCtx.createGain(); chimeGain.gain.value=Math.pow(10,2.5/20); chimeGain.connect(masterG);

  // Optional file BGM
  bgmEl=new Audio(); bgmEl.loop=true; bgmEl.preload='auto'; bgmEl.crossOrigin='anonymous';
  bgmSrc=audioCtx.createMediaElementSource(bgmEl); bgmGain=audioCtx.createGain(); bgmGain.gain.value=0.9; bgmSrc.connect(bgmGain).connect(masterG);

  await initRecorderTap(audioCtx, limiter);
  initSensors();
}

async function ensureRunning(){
  if(!audioCtx) return;
  try{ await audioCtx.resume(); }catch(e){}
  try{ const s=audioCtx.createBufferSource(); s.buffer=audioCtx.createBuffer(1,1,audioCtx.sampleRate); s.connect(audioCtx.destination); s.start(); }catch(e){}
}

function hideUnlock(){ document.getElementById('unlock').classList.add('hide'); }

const state={yaw:0,pitch:0,roll:0}; const ALPHA=0.09;
function wrap180(a){return a>180?a-360:a;} function angDiff(a,b){let d=a-b;while(d>180)d-=360;while(d<-180)d+=360;return d;} function smoothAngles(a,b){return b+angDiff(a,b)*ALPHA;} function sinMap(deg){return Math.sin(deg*Math.PI/180);}
function handleOrient(e){ const yawRaw=(typeof e.alpha==='number')?wrap180(e.alpha):0; const pitchRaw=(typeof e.beta==='number')?e.beta:0; const rollRaw=(typeof e.gamma==='number')?e.gamma:0;
  state.yaw=smoothAngles(yawRaw,state.yaw); state.pitch=smoothAngles(pitchRaw,state.pitch); state.roll=smoothAngles(rollRaw,state.roll);
  if(!audioCtx||!therOsc) return;
  const sy=sinMap(state.yaw), sp=sinMap(state.pitch); const base=220, range=880; const f=base+(sy*0.45+sp*0.55)*range;
  therOsc.frequency.setTargetAtTime(Math.max(40,Math.min(3000,f)),audioCtx.currentTime,0.03);
  const vol=0.02+(sinMap(state.roll)+1)/2*0.08*(parseInt(thgainEl.value,10)/100);
  therGain.gain.linearRampToValueAtTime(vol,audioCtx.currentTime+0.05);
}
function handleMotion(e){ const a=e.accelerationIncludingGravity; if(!a) return; const mag=Math.hypot(a.x||0,a.y||0,a.z||0); const now=performance.now();
  if(mag>28 && (!window._lastShake || now-window._lastShake>600)){ window._lastShake=now; playChime(); }
}
async function initSensors(){ try{ if(typeof DeviceMotionEvent!=='undefined'&&typeof DeviceMotionEvent.requestPermission==='function'){ await DeviceMotionEvent.requestPermission().catch(()=>{});} }catch(e){} window.addEventListener('deviceorientation',handleOrient,true); window.addEventListener('devicemotion',handleMotion,true);
  window.addEventListener('pointermove',(ev)=>{const w=innerWidth,h=innerHeight;const nx=(ev.clientX/w)*2-1;const ny=(ev.clientY/h)*2-1;handleOrient({alpha:nx*90,beta:ny*60,gamma:0});},{passive:true}); }

function playChime(){ if(!chimeBuf||!audioCtx) return; const s=audioCtx.createBufferSource(); s.buffer=chimeBuf; s.connect(chimeGain); s.start(); }

const dbgState=document.getElementById('dbgState');
const dbgSR=document.getElementById('dbgSR');
const dbgT=document.getElementById('dbgT');
function updateDebug(){
  try{
    if(!audioCtx){ dbgState.textContent='no-ctx'; return; }
    dbgState.textContent = audioCtx.state;
    dbgSR.textContent = audioCtx.sampleRate;
    dbgT.textContent = audioCtx.currentTime.toFixed(2);
  }catch(e){}
}
setInterval(updateDebug, 300);

// Recording
function startRec(){ if(!audioCtx) return; ensureRunning(); recBuffers.length=0; recording=true; recSampleRate=audioCtx.sampleRate; recStartBtn.disabled=true; recStopBtn.disabled=false; recStatus.textContent='Recording'; }
function stopRec(){ recording=false; recStartBtn.disabled=false; recStopBtn.disabled=true; recStatus.textContent='Saving...'; const mono=concatFloat32(recBuffers); const pcm16=f32ToPCM16(mono); const wav=muxWAV(pcm16,recSampleRate); const a=document.createElement('a'); a.href=URL.createObjectURL(wav); const ts=new Date().toISOString().replace(/[:.]/g,'-'); a.download='AERIAL_v10_0_'+ts+'.wav'; a.click(); recStatus.textContent='Saved'; }
recStartBtn.onclick = startRec; recStopBtn.onclick = stopRec;

// BGM UI
bgmMode.onchange=()=>{ bgmFile.style.display = (bgmMode.value==='file')?'inline-block':'none'; if(bgmMode.value!=='file' && bgmEl){ bgmEl.pause(); bgmEl.src=''; } };
bgmFile.onchange=async (e)=>{ const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); bgmEl.src=url; try{ await bgmEl.play(); }catch(e){} };

btnPause.onclick=async ()=>{ if(!audioCtx) return; if(audioCtx.state==='running'){ await audioCtx.suspend(); btnPause.textContent='▶ Resume'; } else { await audioCtx.resume(); await ensureRunning(); btnPause.textContent='⏸ Pause'; } };

async function unlockNow(){
  if(!audioCtx){
    const Ctx = window.AudioContext || window.webkitAudioContext;
    audioCtx = new Ctx({latencyHint:'interactive'});
  }
  await setup();
  await ensureRunning();
  try{ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); g.gain.value=0.1; o.frequency.value=660; o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+0.08);}catch(e){}
  hideUnlock();
}
['pointerdown','touchstart','keydown'].forEach(ev=>{ window.addEventListener(ev, unlockNow, {once:false,passive:true}); });
document.getElementById('forceUnlock').onclick = unlockNow;
document.getElementById('btnUnlock').onclick = unlockNow;
document.getElementById('bigStart').onclick = unlockNow;
</script>
</body></html>
