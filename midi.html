<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AERIAL — Sensor MIDI Instrument</title>
  <meta name="theme-color" content="#0e0f12" />
  <link rel="manifest" href="manifest.json?v=1" />
  <link rel="icon" href="icon-192.png" sizes="192x192" />
  <style>
    :root { --bg:#0e0f12; --fg:#e6e6e6; --muted:#8a8f98; --accent:#8fd3ff; }
    *{box-sizing:border-box} html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, Helvetica, Arial, sans-serif;}
    main{max-width:980px;margin:0 auto;padding:16px;display:grid;grid-template-columns:1.2fr .8fr; gap:16px}
    @media (max-width:900px){ main{ grid-template-columns: 1fr; } }
    .panel{background:#12151b;border:1px solid #1f242c;border-radius:14px;padding:14px}
    h1{font-size:18px;margin:0 0 12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    select,button,input[type=number]{background:#0f1320;color:#cfe7ff;border:1px solid #253043;padding:8px 10px;border-radius:10px;font-size:14px}
    label{font-size:12px;color:#a7b2c0;margin-right:4px}
    .kv{display:inline-flex;gap:6px;align-items:center;background:#0f1320;border:1px solid #253043;padding:8px 10px;border-radius:12px;font-size:13px;margin:4px 4px 0 0}
    .muted{color:#8a8f98;font-size:12px}
    #log{font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; white-space:pre-wrap; max-height:180px; overflow:auto; background:#0f1320; border:1px solid #253043; padding:8px; border-radius:10px }
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  </style>
</head>
<body>
<main>
  <section class="panel">
    <h1>Sensor → MIDI</h1>
    <div class="row" style="margin-bottom:8px">
      <label>Output</label>
      <select id="midiOut"></select>
      <label>Ch</label>
      <input id="ch" type="number" min="1" max="16" value="1" style="width:64px" />
      <button id="btnRefresh">🔌 Refresh</button>
      <button id="btnTest">♪ Test Note</button>
      <button id="btnStart">▶ Start</button>
      <button id="btnStop" disabled>⏹ Stop</button>
    </div>
    <div class="grid2">
      <div class="panel" style="background:#0f1320">
        <div class="muted">Mapping（固定値は後で調整可）</div>
        <div class="kv">加速度 (shake) → Kick Note</div>
        <div class="kv">光 (lux) → CC74 (Filter Cutoff)</div>
        <div class="kv">向き (yaw) → CC10 (Pan)</div>
        <div class="kv">動き量 → CC11 (Expression)</div>
        <div class="kv">緯度/時刻 → Key + Tempo</div>
        <div class="kv">環境音量 → Velocity / Beat Intensity</div>
        <div class="kv">鼓動ビート（内蔵）→ Note36/48 + Clock</div>
      </div>
      <div>
        <div class="row">
          <label>BPM</label><input id="bpm" type="number" min="40" max="200" value="80" />
          <label>Root</label><input id="root" type="number" min="36" max="84" value="57" />
          <label>Scale</label>
          <select id="scale">
            <option value="major">Major</option>
            <option value="minor" selected>Minor</option>
            <option value="pent">Pentatonic</option>
          </select>
          <label>Clock</label>
          <select id="clk"><option value="on" selected>Send</option><option value="off">Off</option></select>
        </div>
        <div class="muted" style="margin-top:6px">※外部シンセ/DAW側でMIDI受信を有効化してください</div>
      </div>
    </div>
    <div style="margin-top:10px"><div id="log"></div></div>
  </section>

  <section class="panel">
    <h1>Sensors</h1>
    <div class="row">
      <div class="kv">Noise <span id="noise">-- dB</span></div>
      <div class="kv">Light <span id="light">-- lux</span></div>
      <div class="kv">Motion <span id="motion">--</span></div>
      <div class="kv">Yaw <span id="yaw">--°</span></div>
      <div class="kv">Hour <span id="hour">--:--</span></div>
      <div class="kv">Lat/Lon <span id="latlon">--</span></div>
    </div>
  </section>
</main>

<script>
const els = {
  out: document.getElementById('midiOut'),
  ch: document.getElementById('ch'),
  btnRefresh: document.getElementById('btnRefresh'),
  btnTest: document.getElementById('btnTest'),
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  bpm: document.getElementById('bpm'),
  root: document.getElementById('root'),
  scale: document.getElementById('scale'),
  clk: document.getElementById('clk'),
  noise: document.getElementById('noise'),
  light: document.getElementById('light'),
  motion: document.getElementById('motion'),
  yaw: document.getElementById('yaw'),
  hour: document.getElementById('hour'),
  latlon: document.getElementById('latlon'),
  log: document.getElementById('log'),
};

let midiAccess=null, output=null, midiClockTimer=null, beatTimer=null, melodyTimer=null;
let motionAmt=0, lux=50, yaw=0, audioCtx=null, micAnalyser=null;
let running=false;

// ---------- MIDI basics ----------
async function initMIDI(){
  try {
    midiAccess = await navigator.requestMIDIAccess({ sysex:false });
    refreshOutputs();
    log('MIDI ready');
  } catch(e){ log('MIDI error: ' + e); }
}

function refreshOutputs(){
  els.out.innerHTML = '';
  if (!midiAccess) return;
  midiAccess.outputs.forEach((port)=>{
    const opt = document.createElement('option');
    opt.value = port.id; opt.textContent = port.name;
    els.out.appendChild(opt);
  });
  if (els.out.options.length>0){
    els.out.selectedIndex = 0;
    changeOutput();
  }
}

function changeOutput(){
  const id = els.out.value;
  output = midiAccess.outputs.get(id) || null;
  log('Output: ' + (output?output.name:'none'));
}

function send(status, data1, data2){
  if (!output) return;
  const ch = (parseInt(els.ch.value,10)-1) & 0x0f;
  output.send([status | ch, data1 & 0x7f, data2 & 0x7f]);
}

function sendCC(cc, val){ send(0xB0, cc, val); }
function noteOn(note, vel){ send(0x90, note, vel); }
function noteOff(note){ send(0x80, note, 0); }

function sendClockTick(){ output?.send([0xF8]); } // MIDI Clock tick

// ---------- Sensors ----------
async function ensureMotionPermission(){
  try {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      await DeviceMotionEvent.requestPermission();
    }
  } catch(e){}
  window.addEventListener('devicemotion', ev => {
    const ax = ev.accelerationIncludingGravity?.x||0;
    const ay = ev.accelerationIncludingGravity?.y||0;
    const az = ev.accelerationIncludingGravity?.z||0;
    motionAmt = Math.min(1, Math.sqrt(ax*ax + ay*ay + az*az) / 20);
    els.motion.textContent = motionAmt.toFixed(2);
    // Expression CC11
    sendCC(11, Math.floor(motionAmt*127));
  }, { passive:true });
}

function startOrientation(){
  window.addEventListener('deviceorientation', ev=>{
    yaw = (ev.alpha||0);
    els.yaw.textContent = yaw.toFixed(0)+'°';
    const pan = Math.floor((yaw/360)*127); // CC10
    sendCC(10, pan);
  }, { passive:true });
}

async function startLight(){
  els.hour.textContent = new Date().toTimeString().slice(0,5);
  if ('AmbientLightSensor' in window){
    try{
      const sensor = new AmbientLightSensor();
      sensor.addEventListener('reading', ()=>{
        lux = sensor.illuminance; els.light.textContent = lux.toFixed(0)+' lux';
        const cutoff = Math.max(0, Math.min(127, Math.floor(lux/10))); // CC74
        sendCC(74, cutoff);
      });
      sensor.start();
      return;
    }catch(e){}
  }
  // fallback: time-based lux
  const h = new Date().getHours();
  lux = (h>=7 && h<=17) ? 500 : 50; els.light.textContent = Math.round(lux)+' lux(est)';
  sendCC(74, Math.min(127, Math.floor(lux/10)));
}

async function startGeo(){
  if (!navigator.geolocation) return;
  navigator.geolocation.getCurrentPosition(pos=>{
    const { latitude, longitude } = pos.coords;
    els.latlon.textContent = latitude.toFixed(3)+', '+longitude.toFixed(3);
    // map latitude to key offset
    const keyOff = Math.floor((Math.abs(latitude)%12));
    const root = parseInt(els.root.value,10);
    els.root.value = Math.max(36, Math.min(84, root + keyOff - 6));
  }, err=>{
    els.latlon.textContent = 'denied';
  }, { enableHighAccuracy:false, timeout:3000, maximumAge:600000 });
}

// mic analysis only (no playback)
async function startMicAnalysis(){
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const mic = audioCtx.createMediaStreamSource(stream);
    micAnalyser = audioCtx.createAnalyser(); micAnalyser.fftSize = 1024;
    mic.connect(micAnalyser);
    RAF(); // start analyser loop
  }catch(e){ log('Mic error: '+e); }
}

function RAF(){
  requestAnimationFrame(RAF);
  if (!micAnalyser) return;
  const arr = new Uint8Array(micAnalyser.fftSize/2);
  micAnalyser.getByteFrequencyData(arr);
  let sum=0; for (let i=0;i<arr.length;i++) sum += arr[i]*arr[i];
  const rms = Math.sqrt(sum / arr.length) / 255;
  const db = 20*Math.log10(Math.max(rms,1e-6));
  els.noise.textContent = (db+90).toFixed(1)+' dB';
  // map to velocity intensity base
  beatIntensity = Math.max(0.2, Math.min(1.0, 0.2 + rms*1.6));
}

// ---------- Music logic ----------
const SCALES = {
  major:   [0,2,4,5,7,9,11,12],
  minor:   [0,2,3,5,7,8,10,12],
  pent:    [0,3,5,7,10,12],
};

let beatIntensity = 0.6; // 0..1
let heldNotes = [];

function startHeartbeat(){
  stopHeartbeat();
  const bpm = parseInt(els.bpm.value,10) || 80;
  const interval = 60000 / bpm;
  // MIDI Clock (24 PPQ)
  if (els.clk.value === 'on' && output){
    let ppqCount = 0;
    midiClockTimer = setInterval(()=>{
      sendClockTick();
      if (++ppqCount >= 24){ ppqCount = 0; }
    }, (60000 / bpm) / 24);
  }
  beatTimer = setInterval(()=>{
    // Heartbeat: low-high pattern (kick + soft click)
    const chVel = Math.floor(50 + beatIntensity*60);
    noteOn(36, chVel); // kick 1
    setTimeout(()=>noteOff(36), 80);
    setTimeout(()=>{ noteOn(48, Math.floor(chVel*0.7)); setTimeout(()=>noteOff(48), 60); }, interval*0.33);
  }, interval);
}

function stopHeartbeat(){
  if (beatTimer){ clearInterval(beatTimer); beatTimer=null; }
  if (midiClockTimer){ clearInterval(midiClockTimer); midiClockTimer=null; }
}

function startMelody(){
  stopMelody();
  const root = parseInt(els.root.value,10) || 57;
  const scaleName = els.scale.value; const scale = SCALES[scaleName];
  melodyTimer = setInterval(()=>{
    const deg = Math.floor(Math.random()*scale.length);
    const note = root + scale[deg] + 12; // upper octave
    const vel = Math.floor(30 + motionAmt*60);
    send(0x90, note, vel);
    heldNotes.push(note);
    setTimeout(()=>{
      send(0x80, note, 0);
      heldNotes = heldNotes.filter(n=>n!==note);
    }, 900);
  }, 1800);
}

function stopMelody(){ if (melodyTimer){ clearInterval(melodyTimer); melodyTimer=null; } heldNotes.forEach(n=>send(0x80,n,0)); heldNotes=[]; }

// ---------- UI ----------
function log(s){ els.log.textContent = (new Date()).toLocaleTimeString() + '  ' + s + '\n' + els.log.textContent; }

els.btnRefresh.onclick = ()=> refreshOutputs();
els.out.onchange = changeOutput;

els.btnTest.onclick = ()=>{
  if (!output){ log('No MIDI output selected'); return; }
  const n = parseInt(els.root.value,10)+12;
  noteOn(n,90); setTimeout(()=>noteOff(n), 300);
};

els.btnStart.onclick = async ()=>{
  if (!navigator.requestMIDIAccess){ alert('このブラウザは Web MIDI に対応していません。
Chrome または Chromium系をお試しください。'); return; }
  await initMIDI();
  await ensureMotionPermission();
  startOrientation();
  startLight();
  startGeo();
  await startMicAnalysis();
  startHeartbeat();
  startMelody();
  els.btnStart.disabled = true; els.btnStop.disabled = false;
  running = true;
  log('Started');
};

els.btnStop.onclick = ()=>{
  stopHeartbeat(); stopMelody();
  els.btnStart.disabled = false; els.btnStop.disabled = true;
  running = false;
  log('Stopped');
};
</script>
</body>
</html>
