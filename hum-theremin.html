<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>AERIAL v8.0 — HumTaste × Theremin</title>
<link rel="manifest" href="manifest.json?v=80"/><link rel="icon" href="icon-192.png" sizes="192x192"/>
<style>
  :root{--bg:#0e0f12;--fg:#e6e6e6;--muted:#8a8f98}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,'Noto Sans JP',sans-serif}
  main{max-width:1100px;margin:0 auto;padding:14px;display:grid;grid-template-columns:1.15fr .85fr;gap:12px}
  @media (max-width:920px){main{grid-template-columns:1fr}}
  .card{background:#12151b;border:1px solid #1f242c;border-radius:14px;padding:14px}
  h1{font-size:18px;margin:0 0 10px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  input[type=range],button,select{background:#0f1320;color:#cfe7ff;border:1px solid #253043;border-radius:10px;padding:8px 10px;font-size:14px}
  .kv{display:inline-flex;gap:6px;align-items:center;background:#0f1320;border:1px solid #253043;border-radius:12px;padding:8px 10px;font-size:13px;margin:4px 4px 0 0}
  .muted{color:var(--muted);font-size:12px}
  #canvas{width:100%;height:260px;background: radial-gradient(800px 600px at 50% 60%, #1a1f29, #0b0c0f); border:1px solid #1f242c; border-radius:12px;}
  #log{font-family:ui-monospace,Menlo,monospace;font-size:12px;white-space:pre-wrap;max-height:200px;overflow:auto;background:#0f1320;border:1px solid #253043;border-radius:10px;padding:8px}
  label{font-size:12px;color:#a7b2c0;margin-right:6px}
  .sub{font-size:12px;opacity:.9}
</style>
</head><body>
<main>
  <section class="card">
    <h1>HumTaste Engine × Theremin</h1>
    <canvas id="canvas"></canvas>
    <div class="row" style="margin-top:8px">
      <button id="btnStart">▶ Start</button>
      <button id="btnStop" disabled>⏹ Stop</button>
      <button id="btnUpdate">🔄 Force Reload</button>
      <button id="btnTest">♪ Test</button>
      <label>Master</label><input id="master" type="range" min="0" max="100" value="60"/>
      <span class="muted">Start→Testで音確認。イヤホン推奨。</span>
    </div>

    <div class="row" style="margin-top:8px">
      <strong style="width:100%">🎼 HumTaste Engine</strong>
      <label>BPM</label><input id="bpm" type="range" min="60" max="150" value="92"/>
      <label>Key</label><select id="key"><option>C</option><option>G</option><option>D</option><option>A</option><option>E</option><option>B</option><option>F#</option><option>F</option><option>Bb</option><option>Eb</option><option>Ab</option><option>Db</option><option>Gb</option></select>
      <label>Style</label><select id="style"><option value="ambient">Ambient</option><option value="softbeat" selected>SoftBeat</option><option value="minimal">Minimal</option></select>
      <label>Activity</label><input id="activity" type="range" min="0" max="100" value="55"/>
      <span class="sub">※ Yaw/Roll/Altitude でドラム/ベース/コードのニュアンスが動きます。</span>
    </div>

    <div class="row" style="margin-top:8px">
      <strong style="width:100%">🎚 Theremin（かわいい音）</strong>
      <label>Pitch Range</label><input id="pmin" type="range" min="120" max="500" value="180"/><input id="pmax" type="range" min="500" max="1800" value="960"/>
      <label>Vibrato</label><input id="vib" type="range" min="0" max="100" value="28"/>
      <label>Sweet</label><input id="sweet" type="range" min="0" max="100" value="64"/>
      <label>Alt Sens</label><input id="alts" type="range" min="80" max="700" value="300"/>
      <span class="sub">※ ロール寄与を拡大。高度は音量に強く反映。</span>
    </div>

    <div class="row" style="margin-top:8px">
      <strong style="width:100%">🎛 Output</strong>
      <label>Internal Amp</label><select id="amp"><option value="on" selected>On</option><option value="off">Off</option></select>
      <label>MIDI</label><select id="midiOut"><option value="">(not connected)</option></select>
      <label>Bend Range</label><input id="bend" type="range" min="2" max="24" value="12"/>
      <span class="sub">PitchBend＋CC1/CC74/CC11送出。</span>
    </div>

    <div class="muted" style="margin-top:6px">衝撃→チャイム（控えめ）＆画面バースト。</div>
  </section>

  <section class="card">
    <h1>Status / Sensors</h1>
    <div class="row">
      <div class="kv">Audio <span id="astate">—</span></div>
      <div class="kv">Yaw <span id="yaw">--°</span></div>
      <div class="kv">Pitch <span id="pitch">--°</span></div>
      <div class="kv">Roll <span id="roll">--°</span></div>
      <div class="kv">Altitude <span id="alt">-- m</span></div>
      <div class="kv">Impact <span id="imp">--</span></div>
      <div class="kv">Motion <span id="motion">--</span></div>
      <div class="kv">MIDI <span id="midi">—</span></div>
    </div>
    <div style="margin-top:10px"><div id="log"></div></div>
  </section>
</main>

<script>
const els = {
  canvas: document.getElementById('canvas'),
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  btnUpdate: document.getElementById('btnUpdate'),
  btnTest: document.getElementById('btnTest'),
  master: document.getElementById('master'),
  bpm: document.getElementById('bpm'), key: document.getElementById('key'), style: document.getElementById('style'), activity: document.getElementById('activity'),
  pmin: document.getElementById('pmin'), pmax: document.getElementById('pmax'),
  vib: document.getElementById('vib'), sweet: document.getElementById('sweet'), alts: document.getElementById('alts'),
  amp: document.getElementById('amp'), midiOut: document.getElementById('midiOut'), bend: document.getElementById('bend'),
  yaw: document.getElementById('yaw'), pitch: document.getElementById('pitch'), roll: document.getElementById('roll'),
  alt: document.getElementById('alt'), imp: document.getElementById('imp'), motion: document.getElementById('motion'),
  astate: document.getElementById('astate'), midi: document.getElementById('midi'),
  log: document.getElementById('log'),
};
function log(s){ els.log.textContent = (new Date()).toLocaleTimeString() + '  ' + s + "\n" + els.log.textContent; }

let audioCtx, masterG;
let therOsc, therGain, vibOsc, vibGain, sweetShaper, lp;
let running=false;
let yawN=0.5, pitchN=0.5, rollN=0.5, altitudeM=null, baseAlt=null;
let lastAccMag=null, lastChime=0, burst=0;
let chimeBuf=null;
let midiAccess=null, midiPort=null, lastMidiNote=null;

// ---- HumTaste-like Engine (clock + simple voices) ----
let engine = { started:false, lookahead:0.06, scheduleAhead:0.12, current16th:0, nextTime:0 };
let voices = {};

async function setupAudio(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  masterG = audioCtx.createGain(); masterG.gain.value = els.master.value/100; masterG.connect(audioCtx.destination);
  els.astate.textContent = audioCtx.state; audioCtx.onstatechange = ()=> els.astate.textContent = audioCtx.state;

  // Theremin voice (cute)
  therOsc = audioCtx.createOscillator(); therOsc.type='sine';
  vibOsc  = audioCtx.createOscillator(); vibOsc.type='sine'; vibOsc.frequency.value = 5;
  vibGain = audioCtx.createGain(); vibGain.gain.value = 0; vibOsc.connect(vibGain).connect(therOsc.frequency);
  sweetShaper = audioCtx.createWaveShaper(); sweetShaper.curve = makeCuteCurve(4096, 0.25);
  lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.Q.value = 0.9; lp.frequency.value = 3200;
  therGain = audioCtx.createGain(); therGain.gain.value = 0.06;
  therOsc.connect(sweetShaper).connect(lp).connect(therGain).connect(masterG);
  therOsc.start(); vibOsc.start();

  // Chime preload
  try{ const r=await fetch('chime.mp3'); if(r.ok){ const a=await r.arrayBuffer(); chimeBuf=await audioCtx.decodeAudioData(a); } }catch(e){}

  // Hum voices
  voices.drum = makeDrum();
  voices.bass = makeBass();
  voices.pad  = makePad();
  voices.mel  = makeLead();

  updateTheremin(true);
}

function makeCuteCurve(n, amt){ const c=new Float32Array(n); for(let i=0;i<n;i++){ const x=(i/n)*2-1; c[i]=Math.tanh(x*(1+amt*2))*0.85; } return c; }

// ---- Voices ----
function makeDrum(){ return { trig(t, step){
  // Soft beat: kick on 0, snare on 8, hats with yaw/roll activity
  const act = parseInt(els.activity.value,10)/100;
  const kick = (step%16===0);
  const snr  = (step%16===8) && (els.style.value!=='minimal');
  const hatProb = 0.25 + act*0.5 + yawN*0.25;
  if(kick) tone(t, 60, 0.2, 0.02);
  if(snr)  noise(t, 2000+rollN*3000, 0.12, 0.18);
  if(Math.random()<hatProb) noise(t, 6000+rollN*6000, 0.04, 0.05);
} };}
function makeBass(){ return { trig(t, step, rootFreq){
  // Bass every 4th step with roll accent
  if(step%4===0){
    const g = audioCtx.createGain(); g.gain.value=0; g.connect(masterG);
    const o = audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.value=rootFreq/2;
    const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 220 + rollN*800; f.Q.value = 0.6 + rollN*0.6;
    o.connect(f).connect(g);
    g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.08+rollN*0.06, t+0.01); g.gain.exponentialRampToValueAtTime(0.0008, t+0.45);
    o.start(t); o.stop(t+0.5);
  }
} };}
function makePad(){ return { trig(t, step, chordFreqs){
  if(step%8===0){
    const g = audioCtx.createGain(); g.gain.value=0; g.connect(masterG);
    const f = audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 1000 + rollN*1500; f.Q.value=0.7;
    chordFreqs.forEach((f0,i)=>{ const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=f0; o.connect(f); o.start(t); o.stop(t+1.8); });
    f.connect(g);
    g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.06, t+0.2); g.gain.exponentialRampToValueAtTime(0.001, t+1.8);
  }
} };}
function makeLead(){ return { trig(t, step, scale){
  // occasional melodic ping, more when activity high
  const act = parseInt(els.activity.value,10)/100;
  const prob = 0.15 + act*0.4 + (yawN*0.1);
  if(Math.random()<prob){
    const idx = Math.floor(Math.random()*scale.length);
    const f0 = scale[idx] * (1 + (Math.random()*2-1)*0.02);
    const g = audioCtx.createGain(); g.gain.value=0; g.connect(masterG);
    const o = audioCtx.createOscillator(); o.type='triangle'; o.frequency.value=f0;
    const d = audioCtx.createDelay(); d.delayTime.value = 0.18 + yawN*0.08;
    o.connect(d).connect(g);
    const t0=t;
    g.gain.setValueAtTime(0, t0); g.gain.linearRampToValueAtTime(0.05+rollN*0.03, t0+0.02); g.gain.exponentialRampToValueAtTime(0.001, t0+0.6);
    o.start(t0); o.stop(t0+0.6);
  }
} };}

// Basic building blocks
function tone(t, freq, gain=0.1, dur=0.12){
  const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=freq;
  const g=audioCtx.createGain(); g.gain.value=0; o.connect(g).connect(masterG);
  g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(gain, t+0.005); g.gain.exponentialRampToValueAtTime(0.0008, t+dur);
  o.start(t); o.stop(t+dur+0.05);
}
function noise(t, freq, gain=0.05, dur=0.08){
  const b = audioCtx.createBuffer(1, audioCtx.sampleRate*dur, audioCtx.sampleRate);
  const d = b.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=Math.random()*2-1; }
  const src = audioCtx.createBufferSource(); src.buffer=b;
  const f = audioCtx.createBiquadFilter(); f.type='highpass'; f.frequency.value=freq;
  const g = audioCtx.createGain(); g.gain.value=0;
  src.connect(f).connect(g).connect(masterG);
  g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(gain, t+0.005); g.gain.exponentialRampToValueAtTime(0.0008, t+dur);
  src.start(t); src.stop(t+dur+0.02);
}

// ---- Harmony helpers ----
const SEMI = Math.pow(2,1/12);
function noteHz(n){ return 440*Math.pow(2,(n-69)/12); }
const KEYS = { "C":0,"G":7,"D":14,"A":21,"E":28,"B":35,"F#":42,"F":-5,"Bb":2,"Eb":9,"Ab":16,"Db":23,"Gb":30 };
const IviIVV = [0, -3, -5, -7]; // I, vi, IV, V in semitone offset from key center (approx)
function buildChord(root, type='maj'){ // triads
  if(type==='maj') return [root, root+4, root+7].map(noteHz);
  if(type==='min') return [root, root+3, root+7].map(noteHz);
  return [root];
}
function scaleMajor(root){
  const deg = [0,2,4,5,7,9,11]; return deg.map(s=> noteHz(root+s));
}

// ---- Engine clock ----
function scheduler(){
  if(!engine.started) return;
  const bpm = parseInt(els.bpm.value,10);
  const spb = 60/bpm; // seconds per beat (quarter)
  while(engine.nextTime < audioCtx.currentTime + engine.scheduleAhead){
    const step = engine.current16th % 16;
    // key center
    const k = KEYS[els.key.value]||0;
    const progIdx = Math.floor(engine.current16th/4) % IviIVV.length;
    const deg = IviIVV[progIdx];
    const rootMidi = 60 + k + deg;
    const chord = buildChord(rootMidi + (progIdx===1?-3:0), (progIdx===1?'min':'maj')); // vi is minor-ish
    const scale = scaleMajor(60 + k);

    // voices
    voices.drum.trig(engine.nextTime, step);
    voices.bass.trig(engine.nextTime, step, noteHz(rootMidi));
    voices.pad.trig(engine.nextTime, step, chord);
    voices.mel.trig(engine.nextTime, step, scale);

    engine.nextTime += spb/4; // 16th
    engine.current16th++;
  }
  setTimeout(scheduler, engine.lookahead*1000);
}

// ---- MIDI ----
async function setupMIDI(){
  if (!navigator.requestMIDIAccess){ els.midi.textContent='no WebMIDI'; return; }
  try{
    const access = await navigator.requestMIDIAccess();
    midiAccess = access; els.midiOut.innerHTML = '<option value="">(choose)</option>';
    for (const out of access.outputs.values()){
      const opt = document.createElement('option'); opt.value=out.id; opt.textContent=out.name; els.midiOut.appendChild(opt);
    }
    els.midi.textContent='ready';
    els.midiOut.addEventListener('change', ()=>{
      const id = els.midiOut.value; midiPort = id? access.outputs.get(id): null; els.midi.textContent = midiPort?('out: '+midiPort.name):'ready';
    });
  }catch(e){ els.midi.textContent='denied'; }
}
function freqToMidi(f){ return Math.round(69 + 12*Math.log2(f/440)); }
function sendMIDI(pitchHz, expr){
  if (!midiPort) return;
  const bendRange = parseInt(els.bend.value,10);
  const midi = freqToMidi(pitchHz);
  if (lastMidiNote===null || Math.abs(midi - lastMidiNote) >= 2){
    if (lastMidiNote!=null){ midiPort.send([0x80, lastMidiNote, 0x00]); }
    midiPort.send([0x90, midi, 0x50]); lastMidiNote = midi;
  }
  const targetFreq = 440 * Math.pow(2, (midi-69)/12);
  const cents = 1200 * Math.log2(pitchHz/targetFreq);
  const bend = Math.max(-bendRange*100, Math.min(bendRange*100, cents));
  const pb = Math.round((bend/(bendRange*100))*8191) + 8192;
  const msb = (pb>>7) & 0x7F, lsb = pb & 0x7F;
  midiPort.send([0xE0, lsb, msb]);
  // CCs
  const vib = Math.round((parseInt(els.vib.value,10)/100)*127);
  const timbre = Math.round((parseInt(els.sweet.value,10)/100)*127);
  const expression = Math.round(expr*127);
  midiPort.send([0xB0, 1, vib]);   // CC1
  midiPort.send([0xB0, 74, timbre]); // CC74
  midiPort.send([0xB0, 11, expression]); // CC11
}

// ---- Theremin mapping ----
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function updateTheremin(init=false){
  if (!audioCtx) return;
  const pmin = parseFloat(els.pmin.value), pmax = parseFloat(els.pmax.value);
  const pitchHz = pmin + (pmax - pmin) * clamp01((pitchN*1.03 + yawN*0.08));
  therOsc.frequency.setTargetAtTime(pitchHz, audioCtx.currentTime, init?0:0.02);
  const vib = parseInt(els.vib.value,10)/100;
  vibOsc.frequency.setTargetAtTime(4 + yawN*7, audioCtx.currentTime, 0.2);
  vibGain.gain.setTargetAtTime(vib * (1.8 + rollN*3.2), audioCtx.currentTime, 0.2); // stronger Roll
  const sw = parseInt(els.sweet.value,10)/100;
  lp.frequency.setTargetAtTime(2300 + sw*2700 + rollN*600, audioCtx.currentTime, 0.25);
  // altitude -> volume (strong)
  let vol = 0.06;
  if (altitudeM!=null){
    if (baseAlt==null) baseAlt = altitudeM;
    const sens = parseInt(els.alts.value,10)/100;
    const relM = (altitudeM - baseAlt);
    const rel = clamp01( 0.5 + relM * 0.24 * sens );
    vol = 0.03 + rel*0.9;
  }
  therGain.gain.setTargetAtTime(vol, audioCtx.currentTime, init?0.1:0.12);
  if (els.amp.value==='off' && masterG) masterG.gain.value = 0; else masterG.gain.value = els.master.value/100;
  sendMIDI(pitchHz, therGain.gain.value);
}

// ---- Sensors ----
let motionAmt=0;
async function ensureMotionPermission(){
  try{
    if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ await DeviceMotionEvent.requestPermission(); }
    if (typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){ try{ await DeviceOrientationEvent.requestPermission(); }catch(e){} }
  }catch(e){}
  window.addEventListener('deviceorientation', ev=>{
    const a=(ev.alpha||0), b=(ev.beta||0), g=(ev.gamma||0);
    yawN = (a%360)/360; pitchN = (b + 180)/360; rollN = (g + 90)/180;
    els.yaw.textContent = Math.round(a)+'°'; els.pitch.textContent = Math.round(b)+'°'; els.roll.textContent = Math.round(g)+'°';
    updateTheremin();
  }, {passive:true});

  window.addEventListener('devicemotion', ev=>{
    const ax=ev.accelerationIncludingGravity?.x||0, ay=ev.accelerationIncludingGravity?.y||0, az=ev.accelerationIncludingGravity?.z||0;
    const mag = Math.sqrt(ax*ax+ay*ay+az*az);
    motionAmt = Math.min(1.8, mag/10);
    els.motion.textContent = motionAmt.toFixed(2);
    let jerk=0; if (lastAccMag!=null) jerk=Math.abs(mag-lastAccMag); lastAccMag=mag;
    const threshold = 3.2; // a bit insensitive
    if (jerk > threshold && (performance.now()-lastChime)>1200){
      lastChime = performance.now(); els.imp.textContent='🔔 '+jerk.toFixed(2); triggerChime(); triggerBurst();
    }
  }, {passive:true});
}

async function startAltitude(){
  if (!navigator.geolocation){ els.alt.textContent='N/A'; return; }
  navigator.geolocation.watchPosition(pos=>{
    altitudeM = (pos.coords.altitude!=null) ? pos.coords.altitude : null;
    els.alt.textContent = altitudeM==null? '—' : altitudeM.toFixed(1)+' m';
    updateTheremin();
  }, _=>{ els.alt.textContent='denied'; }, { enableHighAccuracy:true, maximumAge:400, timeout:3500 });
}

// ---- Chime ----
function triggerChime(){
  if (!audioCtx) return;
  const vol = 0.32; // modest
  const g = audioCtx.createGain(); g.gain.value = 0; g.connect(masterG);
  const t = audioCtx.currentTime;
  g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(vol, t+0.01); g.gain.exponentialRampToValueAtTime(0.0008, t+2.4);
  if (chimeBuf){ const s = audioCtx.createBufferSource(); s.buffer = chimeBuf; s.connect(g); s.start(t); }
}

// ---- Visual ----
let particles=[]; function triggerBurst(){ burst = 1.0; }
function draw(){
  const c=els.canvas, ctx=c.getContext('2d');
  const dpr=Math.min(2, devicePixelRatio||1), w=c.clientWidth, h=c.clientHeight;
  if (c.width!==Math.floor(w*dpr) || c.height!==Math.floor(h*dpr)){ c.width=Math.floor(w*dpr); c.height=Math.floor(h*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
  const hue = 210 + (yawN*60|0);
  const g=ctx.createRadialGradient(w*0.5,h*0.55,Math.min(w,h)*0.05,w*0.5,h*0.6,Math.max(w,h)*0.9);
  g.addColorStop(0,`hsla(${hue},60%,${40+rollN*25|0}%,${0.95})`); g.addColorStop(1,'rgba(10,12,16,1)');
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  if (particles.length<160){ for(let i=0;i<3;i++) particles.push({x:Math.random()*w,y:Math.random()*h,r:4+Math.random()*10,v:(Math.random()*2+0.5)}); }
  for(const p of particles){
    p.r += 0.08 + pitchN*0.6 + (burst||0)*p.v*2.2;
    if (p.r>Math.max(w,h)*0.5){ p.r = 4; p.x=Math.random()*w; p.y=Math.random()*h; }
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    ctx.strokeStyle = `hsla(${hue},70%,75%,${0.02 + pitchN*0.1 + (burst||0)*0.18})`;
    ctx.lineWidth = 1 + rollN*2 + (burst||0)*2.2; ctx.stroke();
  }
  burst = (burst||0)*0.92;
  requestAnimationFrame(draw);
}

// ---- Start/Stop/Unlock/MIDI ----
els.master.addEventListener('input', e=>{ if(masterG) masterG.gain.value = (els.amp.value==='on')?(e.target.value/100):0; });
els.amp.addEventListener('change', e=>{ if(masterG) masterG.gain.value = (e.target.value==='on')?(els.master.value/100):0; });

async function startAll(){
  await setupAudio(); await audioCtx.resume();
  const n = audioCtx.createBuffer(1,1,audioCtx.sampleRate); const s = audioCtx.createBufferSource(); s.buffer=n; s.connect(masterG); s.start();
  ensureMotionPermission(); startAltitude(); setupMIDI();
  // engine clock init
  engine.started = true;
  engine.current16th = 0; engine.nextTime = audioCtx.currentTime + 0.05;
  scheduler();
  running=true; els.btnStart.disabled=true; els.btnStop.disabled=false;
  draw(); log('Started v8.0');
}
function stopAll(){
  running=false; els.btnStart.disabled=false; els.btnStop.disabled=true;
  engine.started=false; audioCtx && audioCtx.suspend(); log('Stopped');
}
els.btnStart.onclick = startAll; els.btnStop.onclick = stopAll;
els.btnTest.onclick = async ()=>{
  await setupAudio(); await audioCtx.resume();
  const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value=523.25;
  const g = audioCtx.createGain(); g.gain.value=0; o.connect(g).connect(masterG);
  const t = audioCtx.currentTime; g.gain.linearRampToValueAtTime(0.08, t+0.01); g.gain.exponentialRampToValueAtTime(0.0008, t+1.0);
  o.start(); o.stop(t+1.0); log('Test Tone');
};

// SW
if('serviceWorker' in navigator){
  addEventListener('load', async ()=>{
    const reg = await navigator.serviceWorker.register('./sw.js?v=80');
    els.btnUpdate.onclick = async ()=>{ const r = await navigator.serviceWorker.getRegistration(); await r?.update(); r?.waiting?.postMessage('SKIP_WAITING'); if (!r?.waiting) location.reload(); };
  });
}
</script>
</body></html>
