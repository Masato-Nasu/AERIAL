<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>SonicWeather BGM + Shake Chime — v8.5</title>
<link rel="manifest" href="manifest.json?v=8.5"/>
<link rel="icon" href="icon-192.png" sizes="192x192"/>
<style>
  :root{--bg:#0e0f12;--fg:#e6e6e6;--muted:#8a8f98}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,'Noto Sans JP',sans-serif}
  main{max-width:1000px;margin:0 auto;padding:14px}
  .card{background:#12151b;border:1px solid #1f242c;border-radius:14px;padding:14px;margin-bottom:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  input[type=range],button{background:#0f1320;color:#cfe7ff;border:1px solid #253043;border-radius:10px;padding:8px 10px;font-size:14px}
  .muted{color:var(--muted);font-size:12px}
  #burst{position:fixed;inset:0;pointer-events:none}
</style>
</head><body>
<main>
  <section class="card">
    <h1>SonicWeather BGM + Shake Chime <small style="font-weight:400;opacity:.6">v8.5</small></h1>
    <div class="row">
      <button id="start">▶ Start</button>
      <button id="stop" disabled>⏹ Stop</button>
      <label>Master</label><input id="master" type="range" min="0" max="100" value="70"/>
      <span class="muted" id="status">Idle</span>
    </div>
    <p class="muted">マイクは使用しません。時間・光（推定）・動きで音色がゆるやかに変化。端末を<b>振った時だけ</b>チャイムが鳴ります。</p>
  </section>
</main>
<canvas id="burst"></canvas>

<script>
let audioCtx, masterG, limiter, reverb, padGain, filter, lfo, lfoGain;
let noiseSrc, noiseFilter, noiseGain;
let started=false;
let chimeBuf=null, chimeGain;
let recNode, recBuffers=[], recSampleRate=48000, recording=false, timer=null, recStart=0;
let motionAmt=0, lux=NaN;

const statusEl = document.getElementById('status');
const startBtn = document.getElementById('start'), stopBtn=document.getElementById('stop');
const master = document.getElementById('master');

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function pickBaseHzByHour(){
  const h = new Date().getHours();
  if (h >= 5 && h < 11) return 196;   // G3
  if (h >= 11 && h < 17) return 220;  // A3
  if (h >= 17 && h < 22) return 174.61; // F3
  return 155.56; // D#3
}

function makeImpulseResponse(ctx, duration=2.6, decay=5.0, reverse=false){
  const rate=ctx.sampleRate, length=rate*duration, impulse=ctx.createBuffer(2,length,rate);
  for(let ch=0; ch<2; ch++){
    const data=impulse.getChannelData(ch);
    for(let i=0;i<length;i++){ const t=reverse?(length-i):i; data[i]=(Math.random()*2-1)*Math.pow(1 - t/length, decay); }
  }
  return impulse;
}

async function setup(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive"});
  // master + limiter
  masterG = audioCtx.createGain(); masterG.gain.value = parseInt(master.value,10)/100;
  limiter = audioCtx.createDynamicsCompressor();
  limiter.threshold.value=-8; limiter.knee.value=12; limiter.ratio.value=12; limiter.attack.value=0.003; limiter.release.value=0.25;
  masterG.connect(limiter).connect(audioCtx.destination);

  // reverb bus
  reverb = audioCtx.createConvolver(); reverb.buffer = makeImpulseResponse(audioCtx, 2.8, 6.0, true);
  const revGain = audioCtx.createGain(); revGain.gain.value = 0.25; reverb.connect(revGain).connect(masterG);

  // pad path
  filter = audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=800;
  padGain = audioCtx.createGain(); padGain.gain.value = 0.2;
  padGain.connect(filter); filter.connect(reverb); filter.connect(masterG);

  // gentle LFO
  lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.1;
  lfoGain = audioCtx.createGain(); lfoGain.gain.value=200;
  lfo.connect(lfoGain); lfoGain.connect(filter.frequency); lfo.start();

  // detuned pad oscillators
  const base = pickBaseHzByHour();
  [1, 5/4, 3/2, 2].forEach(r=>{
    const o = audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.value = base*r;
    const vib = audioCtx.createOscillator(); vib.type='sine'; vib.frequency.value = 0.15 + Math.random()*0.1;
    const vg = audioCtx.createGain(); vg.gain.value = 1.5 + Math.random()*1; vib.connect(vg).connect(o.frequency); vib.start();
    const g = audioCtx.createGain(); g.gain.value = 0.08;
    o.connect(g).connect(padGain); o.start();
  });

  // soft air noise
  const noiseBuf = (function(ctx){ const len=ctx.sampleRate*4; const b=ctx.createBuffer(1,len,ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<len;i++) d[i]=Math.random()*2-1; return b; })(audioCtx);
  noiseSrc = audioCtx.createBufferSource(); noiseSrc.buffer = noiseBuf; noiseSrc.loop=true;
  noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type='highpass'; noiseFilter.frequency.value=500;
  noiseGain = audioCtx.createGain(); noiseGain.gain.value=0.02;
  noiseSrc.connect(noiseFilter).connect(noiseGain).connect(reverb); noiseSrc.start();

  // chime buffer for shake
  try{ const r=await fetch('Chime.mp3'); const arr=await r.arrayBuffer(); chimeBuf=await audioCtx.decodeAudioData(arr); }catch(e){ console.warn('Chime load failed', e); }
  chimeGain = audioCtx.createGain(); chimeGain.gain.value = Math.pow(10, 2.5/20); chimeGain.connect(masterG);

  // recorder tap
  await initRecorder();

  // motion permission & handler (shake only)
  try{
    if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      await DeviceMotionEvent.requestPermission().catch(()=>{});
    }
  }catch(e){}
  window.addEventListener('devicemotion', (ev)=>{
    const a = ev.accelerationIncludingGravity; if(!a) return;
    const mag = Math.hypot(a.x||0,a.y||0,a.z||0);
    const now = performance.now();
    if (mag > 28 && (!window._lastShake || now-window._lastShake>600)){ window._lastShake = now; playChime(); burst(); }
    motionAmt = Math.min(1, mag/20);
  }, {passive:true});

  // light fallback (no ALS): estimate by hour
  const h = new Date().getHours();
  lux = (h >= 7 && h <= 17) ? 500 : 50;

  // start viz tick
  tick();
}

async function start(){ await setup(); await audioCtx.resume(); started=true; startBtn.disabled=true; stopBtn.disabled=false; statusEl.textContent='Playing'; }
async function stop(){ if(!audioCtx) return; started=false; startBtn.disabled=false; stopBtn.disabled=true; await audioCtx.suspend(); statusEl.textContent='Stopped'; }

function playChime(){ if(!chimeBuf) return; const src=audioCtx.createBufferSource(); src.buffer=chimeBuf; src.connect(chimeGain); src.start(); }

/* Recorder */
async function initRecorder(){
  const code = `class MixTap extends AudioWorkletProcessor{process(inputs){const ch0=inputs[0]?.[0];if(ch0){this.port.postMessage(ch0);}return true;}}registerProcessor('mix-tap',MixTap);`;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  await audioCtx.audioWorklet.addModule(url);
  recNode = new AudioWorkletNode(audioCtx, 'mix-tap');
  const tap = audioCtx.createGain(); tap.gain.value = 1.0;
  masterG.connect(tap).connect(recNode);
  recNode.port.onmessage = (e)=>{ if(recording) recBuffers.push(new Float32Array(e.data)); };
}
function concatFloat32(arrs){ let n=0; arrs.forEach(a=>n+=a.length); const out=new Float32Array(n); let o=0; for(const a of arrs){ out.set(a,o); o+=a.length; } return out; }
function f32ToPCM16(f32){ const dv=new DataView(new ArrayBuffer(f32.length*2)); for(let i=0;i<f32.length;i++){ let s=Math.max(-1,Math.min(1,f32[i])); dv.setInt16(i*2, s<0? s*0x8000 : s*0x7FFF, true);} return dv; }
function muxWAV(pcm16, sr){ const buf=new ArrayBuffer(44+pcm16.byteLength); const v=new DataView(buf);
  function ws(o,s){ for(let i=0;i<s.length;i++) v.setUint8(o+i, s.charCodeAt(i)); }
  ws(0,'RIFF'); v.setUint32(4,36+pcm16.byteLength,true); ws(8,'WAVE'); ws(12,'fmt ');
  v.setUint32(16,16,true); v.setUint16(20,1,true); v.setUint16(22,1,true); v.setUint32(24,sr,true);
  v.setUint32(28,sr*2,true); v.setUint16(32,2,true); v.setUint16(34,16,true); ws(36,'data'); v.setUint32(40,pcm16.byteLength,true);
  return new Blob([v, pcm16], {type:'audio/wav'});
}
function startRec(){
  if (!audioCtx) return;
  recBuffers.length=0; recSampleRate = audioCtx.sampleRate; recording=true;
  const recBtn = document.getElementById('rec'); const recStopBtn = document.getElementById('recStop');
  recBtn.disabled=true; recStopBtn.disabled=false;
  recStart = performance.now();
  timer = setInterval(()=>{ const s=Math.floor((performance.now()-recStart)/1000); const m=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); rectime.textContent=m+':'+ss; }, 500);
}
function stopRec(){
  recording=false; const recBtn = document.getElementById('rec'); const recStopBtn = document.getElementById('recStop');
  recBtn.disabled=false; recStopBtn.disabled=true; clearInterval(timer); rectime.textContent='00:00';
  const mono = concatFloat32(recBuffers); const pcm16 = f32ToPCM16(mono); const wav = muxWAV(pcm16, recSampleRate);
  const a=document.createElement('a'); const ts=new Date().toISOString().replace(/[:.]/g,'-'); a.href=URL.createObjectURL(wav); a.download='AERIAL_v8_5_'+ts+'.wav'; a.click();
}

/* Viz */
const cvs = document.getElementById('burst'), g = cvs.getContext('2d'); let burstT=0;
function fit(){ const r=window.devicePixelRatio||1; cvs.width=innerWidth*r; cvs.height=innerHeight*r; cvs.style.width=innerWidth+'px'; cvs.style.height=innerHeight+'px'; }
addEventListener('resize', fit); fit();
function burst(){ burstT = performance.now(); }
function tick(){
  requestAnimationFrame(tick);
  // map motion/lux to filter + pad gain + lfo rate
  if (filter && audioCtx){
    const tgtCut = clamp(300 + (lux/1000)*800 + motionAmt*4000, 200, 6000);
    filter.frequency.linearRampToValueAtTime(tgtCut, audioCtx.currentTime + 0.2);
  }
  if (padGain && audioCtx){
    padGain.gain.linearRampToValueAtTime(0.12 + motionAmt*0.18 + (lux>200?0.04:0), audioCtx.currentTime + 0.1);
  }
  if (lfo && audioCtx){
    lfo.frequency.linearRampToValueAtTime(0.05 + motionAmt*0.6 + (lux>200?0.05:0), audioCtx.currentTime + 0.2);
  }
  // draw ring when burst
  const now = performance.now();
  const r=window.devicePixelRatio||1; g.setTransform(r,0,0,r,0,0);
  g.clearRect(0,0,cvs.width,cvs.height);
  if(!burstT) return;
  const dt = (now - burstT)/1000;
  if (dt>0.9){ burstT=0; return; }
  const cx = innerWidth/2, cy = innerHeight*0.25;
  const rad = 30 + dt*420;
  const a = Math.max(0, 1 - dt*1.2);
  g.beginPath(); g.arc(cx, cy, rad, 0, Math.PI*2);
  g.strokeStyle = 'rgba(255,255,255,'+a.toFixed(3)+')';
  g.lineWidth = 2 + 6*(1-a); g.stroke();
}

/* UI */
const rec = document.createElement('button'); rec.id='rec'; rec.textContent='🎙 Start Recording';
const recStop = document.createElement('button'); recStop.id='recStop'; recStop.textContent='⏹ Stop Recording'; recStop.disabled=true;
const rectime = document.createElement('span'); rectime.id='rectime'; rectime.className='muted'; rectime.style.marginLeft='8px'; rectime.textContent='00:00';
document.querySelector('.row').appendChild(rec); document.querySelector('.row').appendChild(recStop); document.querySelector('.row').appendChild(rectime);

startBtn.onclick = async ()=>{ await start(); };
stopBtn.onclick  = async ()=>{ await stop(); };
master.oninput   = e=>{ if(masterG) masterG.gain.value = parseInt(e.target.value,10)/100; };
rec.onclick      = startRec;
recStop.onclick  = stopRec;
</script>

<script>
// SW register handled from index.html; keep version in sync
</script>
</body></html>
