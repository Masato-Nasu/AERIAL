<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<meta http-equiv="cache-control" content="no-store, max-age=0"/>
<title>AERIAL v22.1</title>
<link rel="manifest" href="manifest.json?v=22.1"/>
<link rel="icon" href="icon-192.png" sizes="192x192"/>
<style>
  :root{--bg:#0e0f12;--fg:#e6e6e6;--muted:#8a8f98;--accent:#ff4d4d}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,'Noto Sans JP',sans-serif}
  main{max-width:980px;margin:0 auto;padding:14px}
  .card{background:#12151b;border:1px solid #1f242c;border-radius:12px;padding:12px;margin:12px 0}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button,input,label{background:#0f1320;color:#cfe7ff;border:1px solid #253043;border-radius:8px;padding:8px 10px}
  input[type="range"]{width:160px}
  .muted{color:var(--muted);font-size:13px}
  .chk{display:inline-flex;align-items:center;gap:6px;background:transparent;border:none;padding:0;margin-right:10px}
  .rec-badge{display:inline-flex;align-items:center;gap:8px;padding:4px 8px;border-radius:10px;border:1px solid #442; background:#1a0a0a;color:#ffb3b3}
  .rec-dot{width:10px;height:10px;border-radius:50%;background:var(--accent);animation:blink 1s infinite}
  @keyframes blink{0%,55%{opacity:1}75%{opacity:.25}100%{opacity:1}}
  #unlock{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);backdrop-filter:blur(3px);z-index:10}
  #unlock>div{background:#0f1320;border:1px solid #253043;border-radius:14px;padding:16px 18px;text-align:center}
</style>
</head><body>
<main>
  <section class="card">
    <h1 style="margin:0 0 8px">AERIAL v22.1</h1>
    <div class="row">
      <label>Master</label><input id="master" type="range" min="0" max="100" value="80"/>
      <label>BGM Vol</label><input id="bgmVol" type="range" min="0" max="100" value="70"/>
      <button id="btnPick" class="btn">音楽を選ぶ</button>
      <button id="btnStopMusic" class="btn" disabled>音楽を止める</button>
      <input id="bgmFile" type="file" style="display:none"/>
      <button id="recStart" class="btn">🎙 Start Recording</button>
      <button id="recStop" class="btn" disabled>⏹ Stop</button>
      <span id="recStatus" class="muted">Idle</span>
      <span id="recBadge" class="rec-badge" style="display:none"><span class="rec-dot"></span>REC</span>
    </div>
    <div class="row" style="margin-top:8px">
      <span class="muted">環境音（複数選択）:</span>
      <label class="chk"><input type="checkbox" id="env-birds"/>鳥</label>
      <label class="chk"><input type="checkbox" id="env-wind"/>風</label>
      <label class="chk"><input type="checkbox" id="env-waves"/>波</label>
      <label class="chk"><input type="checkbox" id="env-rain"/>雨</label>
      <label class="chk"><input type="checkbox" id="env-cafe"/>カフェ</label>
      <span class="muted">※ 外部BGM再生中は自動ミュート（BGM Vol は環境音にも反映）</span>
    </div>
    <p class="muted">角度マッピング：<b>0°最小 → 180°最大 → 360°で最小</b>（cos連続）。音源選択で録音UIは表示されません。</p>
  </section>
</main>
<div id="unlock"><div>
  <p style="margin:0 0 8px">音を出すには「Start」をタップしてください。</p>
  <button id="btnOverlayStart" class="btn">▶ Start</button>
</div></div>
<script>
if('serviceWorker' in navigator){
  addEventListener('load', async ()=>{ try{ await navigator.serviceWorker.register('./sw.js?v=22.1&bust='+Date.now()); }catch(e){} });
}
</script>
<script>
let audioCtx=null, masterG;
let therOsc, therGain, therFilter, lfoAmp, lfoAmpG, lfoVib, lfoVibG;
let chimeBuf=null, chimeGain;
let bgmEl=null, bgmSrc=null, bgmGain=null;
let recBuffers=[], recording=false, recSampleRate=48000;
let envMaster=null, env={};
let recorder=null, recChunks=[], streamDest=null;
const masterEl=document.getElementById('master');
const bgmVolEl=document.getElementById('bgmVol');
const btnPick=document.getElementById('btnPick');
const btnStopMusic=document.getElementById('btnStopMusic');
const bgmFile=document.getElementById('bgmFile');
const recStartBtn=document.getElementById('recStart'), recStopBtn=document.getElementById('recStop'), recStatus=document.getElementById('recStatus');
const recBadge=document.getElementById('recBadge');
const overlay=document.getElementById('unlock'), btnOverlayStart=document.getElementById('btnOverlayStart');
const envChecks={ birds:el('birds'), wind:el('wind'), waves:el('waves'), rain:el('rain'), cafe:el('cafe') };
function el(id){ return document.getElementById('env-'+id); }
const toRad = d=>d*Math.PI/180;
// 円滑平滑（角度の継ぎ目なし）
let cx=1, sx=0;
function updateBeta(betaDeg){ const r=toRad(betaDeg); const c=Math.cos(r), s=Math.sin(r); const a=0.9; cx=a*cx+(1-a)*c; sx=a*sx+(1-a)*s; }
function getP(){ const ang=Math.atan2(sx,cx); const deg=(ang*180/Math.PI+360)%360; return (1-Math.cos(toRad(deg)))/2; }
function anyEnvSelected(){ return Object.values(envChecks).some(cb=>cb.checked); }
async function setup(){
  if(audioCtx) return;
  audioCtx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
  masterG=audioCtx.createGain(); masterG.gain.value=parseInt(masterEl.value,10)/100;
  const limiter=audioCtx.createDynamicsCompressor(); limiter.threshold.value=-6;limiter.knee.value=14;limiter.ratio.value=14;limiter.attack.value=0.003;limiter.release.value=0.25;
  masterG.connect(limiter); limiter.connect(audioCtx.destination);
  streamDest = audioCtx.createMediaStreamDestination(); limiter.connect(streamDest);
  try{ const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : (MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : ''); recorder = new MediaRecorder(streamDest.stream, mime? {mimeType:mime}:{}); recorder.ondataavailable = ev => { if(ev.data && ev.data.size>0) recChunks.push(ev.data); }; recorder.onstop = ()=>{ const blob = new Blob(recChunks, {type: recorder.mimeType || 'audio/webm'}); recChunks.length=0; downloadBlob(blob, 'AERIAL_v22.1_'+ts()+(blob.type.includes('webm')?'.webm':'.wav')); recStatus.textContent='Idle'; }; }catch(e){ recorder=null; }
  masterEl.oninput=()=>{ if(masterG) masterG.gain.value=parseInt(masterEl.value,10)/100; };
  envMaster=audioCtx.createGain(); envMaster.gain.value=0.0; envMaster.connect(masterG);
  therOsc=audioCtx.createOscillator(); therOsc.type='sine';
  therFilter=audioCtx.createBiquadFilter(); therFilter.type='lowpass'; therFilter.frequency.value=2600; therFilter.Q.value=0.7;
  therGain=audioCtx.createGain(); therGain.gain.value=0.10;
  therOsc.connect(therFilter).connect(therGain).connect(masterG); therOsc.start();
  lfoAmp=audioCtx.createOscillator(); lfoAmp.type='sine'; lfoAmp.frequency.value=1.2;
  lfoAmpG=audioCtx.createGain(); lfoAmpG.gain.value=0.06; lfoAmp.connect(lfoAmpG).connect(therGain.gain); lfoAmp.start();
  lfoVib=audioCtx.createOscillator(); lfoVib.type='sine'; lfoVib.frequency.value=5.5;
  lfoVibG=audioCtx.createGain(); lfoVibG.gain.value=6; lfoVib.connect(lfoVibG).connect(therOsc.frequency); lfoVib.start();
  try{ const r=await fetch('Chime.mp3'); const ab=await r.arrayBuffer(); chimeBuf=await audioCtx.decodeAudioData(ab);}catch(e){}
  chimeGain=audioCtx.createGain(); chimeGain.gain.value=Math.pow(10,2.5/20); chimeGain.connect(masterG);
  bgmEl=new Audio(); bgmEl.loop=true; bgmEl.preload='auto'; bgmEl.crossOrigin='anonymous';
  bgmSrc=audioCtx.createMediaElementSource(bgmEl); bgmGain=audioCtx.createGain(); bgmGain.gain.value=parseInt(bgmVolEl.value,10)/100;
  bgmSrc.connect(bgmGain).connect(masterG);
  ['play','pause','ended','error','canplay'].forEach(ev=>bgmEl.addEventListener(ev, handleBgmState, {passive:true}));
  bgmVolEl.oninput=syncSharedVolume;
  try{ if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ await DeviceMotionEvent.requestPermission().catch(()=>{}); } }catch(e){}
  addEventListener('deviceorientation',e=>{ if(typeof e.beta==='number') updateBeta(e.beta); }, true);
  addEventListener('pointermove',(ev)=>{ const ny=(ev.clientY/innerHeight); const beta=ny*180; updateBeta(beta); },{passive:true});
  requestAnimationFrame(updateTheremin);
}
function handleBgmState(){ updateStopButton(); syncSharedVolume(); }
function updateStopButton(){ const running = !!(bgmEl && !bgmEl.paused && !bgmEl.ended && bgmEl.src); btnStopMusic.disabled=!running; }
function syncSharedVolume(){ if(!audioCtx) return; const v = parseInt(bgmVolEl.value,10)/100; if(bgmGain) bgmGain.gain.value=v; const active = !!(bgmEl && !bgmEl.paused && !bgmEl.ended && bgmEl.src); const target = active ? 0.0 : (anyEnvSelected()? Math.max(0.16, v*0.48) : 0.0); envMaster.gain.cancelScheduledValues(audioCtx.currentTime); envMaster.gain.linearRampToValueAtTime(target, audioCtx.currentTime+0.08); }
function setEnvMuted(muted){ if(!envMaster || !audioCtx) return; const v = parseInt(bgmVolEl.value,10)/100; const target = muted ? 0.0 : (anyEnvSelected()? Math.max(0.16, v*0.48) : 0.0); envMaster.gain.cancelScheduledValues(audioCtx.currentTime); envMaster.gain.linearRampToValueAtTime(target, audioCtx.currentTime+0.1); }
function noiseBuffer(seconds=2){ const b=audioCtx.createBuffer(1,Math.max(1,Math.floor(audioCtx.sampleRate*seconds)),audioCtx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1); return b; }
function pinkNoiseBuffer(seconds=2){ const sr=audioCtx.sampleRate, n=Math.max(1,Math.floor(sr*seconds)); const b=audioCtx.createBuffer(1,n,sr); const d=b.getChannelData(0); let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0; for(let i=0;i<n;i++){ const white=Math.random()*2-1; b0=0.99886*b0 + white*0.0555179; b1=0.99332*b1 + white*0.0750759; b2=0.96900*b2 + white*0.1538520; b3=0.86650*b3 + white*0.3104856; b4=0.55000*b4 + white*0.5329522; b5=-0.7616*b5 - white*0.0168980; d[i]=b0+b1+b2+b3+b4+b5+b6*0.5362; d[i]*=0.11; b6=white*0.115926; } return b; }
function env_start(type){ if(env[type]?.on) return; env[type]={on:true, stop:()=>{}}; const panOK = typeof audioCtx.createStereoPanner === 'function';
  switch(type){
    case 'wind':{ const src=audioCtx.createBufferSource(); src.buffer=noiseBuffer(4); src.loop=true; const lp=audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=700; const lfo=audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.08; const lfoG=audioCtx.createGain(); lfoG.gain.value=500; lfo.connect(lfoG).connect(lp.frequency); lfo.start(); const g=audioCtx.createGain(); g.gain.value=0.34; const p=panOK?audioCtx.createStereoPanner():null; (p? src.connect(lp).connect(g).connect(p).connect(envMaster) : src.connect(lp).connect(g).connect(envMaster)); src.start(); env[type].stop=()=>{ try{src.stop();}catch{} try{lfo.stop();}catch{} }; }break;
    case 'waves':{ const src=audioCtx.createBufferSource(); src.buffer=pinkNoiseBuffer(4); src.loop=true; const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=180; bp.Q.value=0.6; const swell=audioCtx.createOscillator(); swell.type='sine'; swell.frequency.value=0.16; const swellG=audioCtx.createGain(); swellG.gain.value=0.35; const g=audioCtx.createGain(); g.gain.value=0.34; swell.connect(swellG).connect(g.gain); const p=panOK?audioCtx.createStereoPanner():null; (p? src.connect(bp).connect(g).connect(p).connect(envMaster) : src.connect(bp).connect(g).connect(envMaster)); src.start(); swell.start(); env[type].stop=()=>{ try{src.stop();}catch{} try{swell.stop();}catch{} }; }break;
    case 'rain':{ // --- More natural rain: body + hiss + randomized drops + gentle AM ---
      // Body layer
      const body=audioCtx.createBufferSource(); body.buffer=pinkNoiseBuffer(4); body.loop=true;
      const bpBody=audioCtx.createBiquadFilter(); bpBody.type='bandpass'; bpBody.frequency.value=1000; bpBody.Q.value=0.8;
      const gBody=audioCtx.createGain(); gBody.gain.value=0.22;
      // Hiss layer
      const hiss=audioCtx.createBufferSource(); hiss.buffer=noiseBuffer(4); hiss.loop=true;
      const hpHiss=audioCtx.createBiquadFilter(); hpHiss.type='highpass'; hpHiss.frequency.value=4500;
      const gHiss=audioCtx.createGain(); gHiss.gain.value=0.08;
      // Gentle AM to avoid static
      const am=audioCtx.createOscillator(); am.type='sine'; am.frequency.value=0.12;
      const amG=audioCtx.createGain(); amG.gain.value=0.15; // ±15%
      const gSum=audioCtx.createGain(); gSum.gain.value=1.0;
      am.connect(amG).connect(gSum.gain);
      const chainBody = body.connect(bpBody).connect(gBody).connect(gSum);
      const chainHiss = hiss.connect(hpHiss).connect(gHiss).connect(gSum);
      const p=panOK?audioCtx.createStereoPanner():null;
      (p? gSum.connect(p).connect(envMaster) : gSum.connect(envMaster));
      body.start(); hiss.start(); am.start();
      // Randomized drops
      let alive=true;
      function dropBurst(){
        if(!alive) return;
        const src=audioCtx.createBufferSource(); src.buffer=noiseBuffer(0.08);
        const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=2600+Math.random()*1200; bp.Q.value=8;
        const eg=audioCtx.createGain(); eg.gain.value=0.0;
        src.connect(bp).connect(eg).connect(gSum);
        const t=audioCtx.currentTime;
        eg.gain.setValueAtTime(0.0,t);
        eg.gain.linearRampToValueAtTime(0.9,t+0.01);
        eg.gain.exponentialRampToValueAtTime(0.0001,t+0.22);
        src.start(t); src.stop(t+0.25);
        setTimeout(dropBurst, 80+Math.random()*140);
      }
      dropBurst();
      env[type].stop=()=>{ alive=false; try{body.stop();}catch{} try{hiss.stop();}catch{} try{am.stop();}catch{} };
    }break;
    case 'cafe':{ // --- Louder & richer cafe ambience ---
      const voices=[];
      const centers=[550,850,1100,1400,1700];
      const panOKLocal = panOK && typeof audioCtx.createStereoPanner==='function';
      for(const fc of centers){
        const src=audioCtx.createBufferSource(); src.buffer=pinkNoiseBuffer(3.0); src.loop=true;
        const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=fc; bp.Q.value=1.0;
        const am=audioCtx.createOscillator(); am.type='sine'; am.frequency.value=0.5+Math.random()*1.1;
        const amG=audioCtx.createGain(); amG.gain.value=0.28+Math.random()*0.22;
        const g=audioCtx.createGain(); g.gain.value=0.26; // louder than before
        am.connect(amG).connect(g.gain);
        if(panOKLocal){ const p=audioCtx.createStereoPanner(); p.pan.value=(Math.random()*2-1)*0.65; src.connect(bp).connect(g).connect(p).connect(envMaster); }
        else { src.connect(bp).connect(g).connect(envMaster); }
        src.start(); am.start();
        voices.push(()=>{ try{src.stop();}catch{} try{am.stop();}catch{} });
      }
      // Occasional "clink" sounds
      let alive=true;
      function clink(){
        if(!alive) return;
        const src=audioCtx.createBufferSource(); src.buffer=noiseBuffer(0.05);
        const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=2800+Math.random()*1800; bp.Q.value=10;
        const eg=audioCtx.createGain(); eg.gain.value=0.0;
        const t=audioCtx.currentTime;
        src.connect(bp).connect(eg).connect(envMaster);
        eg.gain.setValueAtTime(0.0,t);
        eg.gain.linearRampToValueAtTime(0.7,t+0.005);
        eg.gain.exponentialRampToValueAtTime(0.0001,t+0.18);
        src.start(t); src.stop(t+0.2);
        setTimeout(clink, 1200+Math.random()*2200);
      }
      clink();
      env[type].stop=()=>{ alive=false; voices.forEach(fn=>fn()); };
    }break;
    case 'birds':{ const g=audioCtx.createGain(); g.gain.value=0.16; g.connect(envMaster); let alive=true; function chirp(){ if(!alive) return; const c=audioCtx.createOscillator(); c.type='sine'; const m=audioCtx.createOscillator(); m.type='sine'; const idx=audioCtx.createGain(); idx.gain.value=900; m.frequency.value=1200+Math.random()*800; c.frequency.value=2200+Math.random()*1800; m.connect(idx).connect(c.frequency); const eg=audioCtx.createGain(); eg.gain.value=0.0; const pan=(typeof audioCtx.createStereoPanner==='function')?audioCtx.createStereoPanner():null; (pan? (eg.connect(pan),pan.connect(g)) : eg.connect(g)); c.connect(eg); const t=audioCtx.currentTime; eg.gain.setValueAtTime(0.0,t); eg.gain.linearRampToValueAtTime(0.6,t+0.02); eg.gain.exponentialRampToValueAtTime(0.0001,t+0.18); if(pan) pan.pan.setValueAtTime((Math.random()*2-1)*0.7, t); c.start(t); m.start(t); c.stop(t+0.2); m.stop(t+0.2); setTimeout(chirp, 250+Math.random()*900); } chirp(); env[type].stop=()=>{ alive=false; }; }break;
  }
}
function env_stop(type){ if(!env[type]?.on) return; try{ env[type].stop(); }catch(e){} env[type].on=false; }
Object.entries(envChecks).forEach(([k,cb])=>cb.addEventListener('change', ()=>{ cb.checked? env_start(k) : env_stop(k); setEnvMuted(!!(bgmEl && !bgmEl.paused && !bgmEl.ended && bgmEl.src)); }, {passive:true}));
function updateTheremin(){ if(!audioCtx) return requestAnimationFrame(updateTheremin); const P = getP(); const base=220, range=1100; const f = base + P * range; therOsc.frequency.setTargetAtTime(Math.max(40,Math.min(3200,f)), audioCtx.currentTime, 0.03); const vol = 0.08 + P * 0.30; therGain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime+0.05); therFilter.frequency.linearRampToValueAtTime(1800 + P*2600, audioCtx.currentTime+0.06); requestAnimationFrame(updateTheremin); }
function handleMotion(e){ const a=e.accelerationIncludingGravity; const mag=Math.hypot(a?.x||0,a?.y||0,a?.z||0); const now=performance.now(); if(mag>28 && (!window._lastShake || now-window._lastShake>600)){ window._lastShake=now; playChime(); } }
function playChime(){ if(!chimeBuf || !audioCtx) return; const s=audioCtx.createBufferSource(); s.buffer=chimeBuf; const g=audioCtx.createGain(); g.gain.value=0.6; s.connect(g).connect(chimeGain).connect(masterG); s.start(); }
function ts(){ return (new Date()).toISOString().replace(/[:.]/g,'-'); }
function downloadBlob(blob, name){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); }
let workletNode=null, workletTap=null;
async function initWorkletFallback(){ if(!audioCtx || workletNode) return; const code=`class MixTap extends AudioWorkletProcessor{process(i){const ch=i[0]?.[0];if(ch){this.port.postMessage(ch.slice());}return true;}}registerProcessor('mix-tap',MixTap);`; const blob=new Blob([code],{type:'application/javascript'}); const url=URL.createObjectURL(blob); await audioCtx.audioWorklet.addModule(url); workletNode=new AudioWorkletNode(audioCtx,'mix-tap'); workletTap=audioCtx.createGain(); workletTap.gain.value=1.0; masterG.connect(workletTap).connect(workletNode); workletNode.port.onmessage=(e)=>{ if(recording && e.data) recBuffers.push(new Float32Array(e.data)); }; }
function startRec(){ if(!audioCtx) return; recStatus.textContent='Recording'; recStatus.style.color='#ffb3b3'; recBadge.style.display='inline-flex'; recStartBtn.disabled=true; recStopBtn.disabled=false; recording=true; if(recorder){ recChunks.length=0; try{ recorder.start(100); }catch(e){ console.warn('MediaRecorder start failed', e); } } else { recBuffers.length=0; recSampleRate=audioCtx.sampleRate; initWorkletFallback(); } }
function stopRec(){ recording=false; recStartBtn.disabled=false; recStopBtn.disabled=true; recStatus.textContent='Saving...'; recStatus.style.color=''; recBadge.style.display='none'; if(recorder && recorder.state!=='inactive'){ try{ recorder.stop(); }catch(e){ console.warn('MediaRecorder stop failed', e); recStatus.textContent='Idle'; } } else { const pcm16=f32ToPCM16(concatFloat32(recBuffers)); const wav=muxWAV(pcm16, recSampleRate||48000); downloadBlob(wav, 'AERIAL_v22.1_'+ts()+'.wav'); recStatus.textContent='Idle'; } }
function concatFloat32(arrs){let n=0;arrs.forEach(a=>n+=a.length);const out=new Float32Array(n);let o=0;for(const a of arrs){out.set(a,o);o+=a.length;}return out;}
function f32ToPCM16(f32){const dv=new DataView(new ArrayBuffer(f32.length*2));for(let i=0;i<f32.length;i++){let s=Math.max(-1,Math.min(1,f32[i]));dv.setInt16(i*2,s<0? s*0x8000 : s*0x7FFF,true);}return dv;}
function muxWAV(pcm16,sr){const buf=new ArrayBuffer(44+pcm16.byteLength);const v=new DataView(buf);function ws(o,s){for(let i=0;i<s.length;i++)v.setUint8(o+i,s.charCodeAt(i));}ws(0,'RIFF');v.setUint32(4,36+pcm16.byteLength,true);ws(8,'WAVE');ws(12,'fmt ');v.setUint32(16,16,true);v.setUint16(20,1,true);v.setUint16(22,1,true);v.setUint32(24,sr,true);v.setUint32(28,sr*2,true);v.setUint16(32,2,true);v.setUint16(34,16,true);ws(36,'data');v.setUint32(40,pcm16.byteLength,true);return new Blob([v,pcm16],{type:'audio/wav'});}
btnOverlayStart.onclick = async ()=>{ try{ if(!audioCtx) await setup(); await audioCtx.resume(); const s=audioCtx.createBufferSource(); s.buffer=audioCtx.createBuffer(1,1,audioCtx.sampleRate); s.connect(audioCtx.destination); s.start(); overlay.style.display='none'; }catch(e){} };
btnPick.onclick=async ()=>{ const ua=navigator.userAgent||''; const isiOS=/iPhone|iPad|iPod/.test(ua); const isSafari=/Safari/.test(ua)&&!/Chrome|Chromium|Android/.test(ua); if('showOpenFilePicker' in window){ try{ const [h]=await window.showOpenFilePicker({multiple:false, types:[{description:'Audio', accept:{'audio/*':['.mp3','.m4a','.aac','.wav','.ogg','.flac','.aiff','.aif','.opus','.mka']}}]}); const file=await h.getFile(); const url=URL.createObjectURL(file); await audioCtx.resume(); bgmEl.src=url; await bgmEl.play(); return; }catch(e){} } if(isiOS&&isSafari){ bgmFile.setAttribute('accept',''); } else { bgmFile.setAttribute('accept','.mp3,.m4a,.aac,.wav,.ogg,.flac,.aiff,.aif,.opus,.mka'); } if('showPicker' in HTMLInputElement.prototype) bgmFile.showPicker(); else bgmFile.click(); };
bgmFile.onchange=async (e)=>{ const f=e.target.files&&e.target.files[0]; if(!f) return; if(!/\.(mp3|m4a|aac|wav|ogg|flac|aiff?|opus|mka)$/i.test(f.name)){ alert('音楽ファイルを選んでください'); e.target.value=''; return; } const url=URL.createObjectURL(f); await audioCtx.resume(); bgmEl.src=url; try{ await bgmEl.play(); }catch(e){} };
btnStopMusic.onclick=()=>{ try{ bgmEl.pause(); bgmEl.currentTime=0; bgmEl.src=''; }catch(e){} updateStopButton(); syncSharedVolume(); };
recStartBtn.onclick=startRec; recStopBtn.onclick=stopRec;
addEventListener('devicemotion',handleMotion,true);
</script>
</body></html>
