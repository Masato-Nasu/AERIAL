<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>HumTaste × Theremin — v8.2</title>
<link rel="manifest" href="manifest.json?v=8.2"/><link rel="icon" href="icon-192.png" sizes="192x192"/>
<style>
  :root{--bg:#0e0f12;--fg:#e6e6e6;--muted:#8a8f98}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,'Noto Sans JP',sans-serif}
  main{max-width:1000px;margin:0 auto;padding:14px}
  .card{background:#12151b;border:1px solid #1f242c;border-radius:14px;padding:14px;margin-bottom:12px;position:relative;overflow:hidden}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  input[type=range],button,select{background:#0f1320;color:#cfe7ff;border:1px solid #253043;border-radius:10px;padding:8px 10px;font-size:14px}
  .muted{color:var(--muted);font-size:12px}
  #burst{position:fixed;inset:0;pointer-events:none}
</style>
</head><body>
<main>
  <section class="card">
    <h1>HumTaste Engine × Theremin <small style="font-weight:400;opacity:.6">v8.2</small></h1>
    <div class="row">
      <button id="start">▶ Start</button>
      <button id="stop" disabled>⏹ Stop</button>
      <button id="chime">🔔 Chime</button>
      <label>Master</label><input id="master" type="range" min="0" max="100" value="60"/>
    </div>
    <div class="row" style="margin-top:8px">
      <label>BPM</label><input id="bpm" type="range" min="60" max="150" value="92"/>
      <label>Key</label><select id="key"><option>C</option><option>G</option><option>D</option></select>
      <label>Activity</label><input id="activity" type="range" min="0" max="100" value="55"/>
    </div>
    <div class="row" style="margin-top:8px">
      <label>Pitch Range</label><input id="pmin" type="range" min="120" max="500" value="180"/><input id="pmax" type="range" min="500" max="1800" value="960"/>
      <label>Vibrato</label><input id="vib" type="range" min="0" max="100" value="28"/>
      <label>Alt Sens</label><input id="alts" type="range" min="80" max="700" value="300"/>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="rec">🎙 Start Recording</button>
      <button id="recStop" disabled>⏹ Stop Recording</button>
      <span id="rectime" class="muted">00:00</span>
      <span class="muted" id="orient">Yaw 0° / Pitch 0° / Roll 0°</span>
    </div>
    <p class="muted">テルミン小さめ、HumTaste強化、チャイム+2.5dB（chime.mp3）、Yaw/Pitch/Roll を正弦＋EMAスムージング、Pitch感度×1.5、WAV録音（Worklet）。</p>
  </section>
</main>
<canvas id="burst"></canvas>
<script>
// ===== Audio Setup =====
let audioCtx, masterG, limiter;
let therOsc, therGain, vibOsc, vibGain, padFilter;
let started=false;
let chimeBuf=null; let chimeGain;
const CHIME_GAIN = Math.pow(10, 2.5/20); // +2.5 dB

async function setup(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive"});

  // Master + limiter
  masterG = audioCtx.createGain(); masterG.gain.value = parseInt(master.value,10)/100;
  limiter = audioCtx.createDynamicsCompressor();
  limiter.threshold.value = -8; limiter.knee.value = 12; limiter.ratio.value = 12; limiter.attack.value = 0.003; limiter.release.value = 0.25;
  masterG.connect(limiter).connect(audioCtx.destination);

  // HumTaste — saw stack into creamy LPF + subtle noise
  padFilter = audioCtx.createBiquadFilter(); padFilter.type='lowpass'; padFilter.frequency.value = 1800; padFilter.Q.value = 0.7;
  const padGain = audioCtx.createGain(); padGain.gain.value = 0.9; padFilter.connect(padGain).connect(masterG);
  [110,220,330].forEach((f,i)=>{
    const o = audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.value=f;
    const g = audioCtx.createGain(); g.gain.value = 0.1 * (1 - i*0.25);
    o.connect(g).connect(padFilter); o.start();
  });
  const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
  const ch = noiseBuf.getChannelData(0); for(let i=0;i<ch.length;i++) ch[i]=(Math.random()*2-1)*0.04;
  const nsrc = audioCtx.createBufferSource(); nsrc.buffer=noiseBuf; nsrc.loop=true;
  const nfil = audioCtx.createBiquadFilter(); nfil.type='bandpass'; nfil.frequency.value=900; nfil.Q.value=0.5;
  const ng = audioCtx.createGain(); ng.gain.value=0.18; nsrc.connect(nfil).connect(ng).connect(padFilter); nsrc.start();

  // Theremin small
  therOsc = audioCtx.createOscillator(); therOsc.type='triangle';
  therGain = audioCtx.createGain(); therGain.gain.value = 0.012; // small
  vibOsc  = audioCtx.createOscillator(); vibOsc.type='sine'; vibOsc.frequency.value = 5.2;
  vibGain = audioCtx.createGain(); vibGain.gain.value = 6; vibOsc.connect(vibGain).connect(therOsc.frequency);
  therOsc.connect(therGain).connect(masterG);
  therOsc.start(); vibOsc.start();

  // Chime buffer
  try{
    const res = await fetch('chime.mp3'); const arr = await res.arrayBuffer(); chimeBuf = await audioCtx.decodeAudioData(arr);
  }catch(e){ console.warn('chime load failed', e); }
  chimeGain = audioCtx.createGain(); chimeGain.gain.value = CHIME_GAIN; chimeGain.connect(masterG);

  // Visibility resume
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && audioCtx.state!=='running') audioCtx.resume(); }, {passive:true});

  await initRecorder();
}
async function start(){ await setup(); await audioCtx.resume(); started=true; startBtn.disabled=true; stopBtn.disabled=false; }
async function stop(){ if(!audioCtx) return; started=false; startBtn.disabled=false; stopBtn.disabled=true; await audioCtx.suspend(); }
async function playChime(){ await setup(); if(!chimeBuf) return;
  const src = audioCtx.createBufferSource(); src.buffer = chimeBuf; src.connect(chimeGain).connect(masterG); src.start();
  burst();
}

// ===== Simple sequencer (same as before) =====
function tone(t, f, g=0.1, d=0.1){
  const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.value=f;
  const G=audioCtx.createGain(); G.gain.value=0; o.connect(G).connect(masterG);
  G.gain.linearRampToValueAtTime(g, t+0.01); G.gain.exponentialRampToValueAtTime(0.0008, t+d);
  o.start(t); o.stop(t+d+0.02);
}
function schedule(){
  const bpm = parseInt(bpmEl.value,10), spb = 60/bpm;
  let t = audioCtx.currentTime;
  for(let i=0;i<16;i++){
    const step = i%16;
    if(step%4===0) tone(t, 60, 0.2*1.8, 0.02);
    if(step%8===0) tone(t, 220, 0.06*1.8, 0.18);
    t += spb/4;
  }
}

// ===== Device Orientation smoothing (sin + EMA) =====
const state = { yaw:0, pitch:0, roll:0 };
const ALPHA = 0.08; // EMA
const PITCH_SENS = 1.5;
function wrap180(a){ return a>180? a-360 : a; }
function angDiff(a,b){ let d=a-b; while(d>180) d-=360; while(d<-180) d+=360; return d; }
function smoothAngles(a,b){ return b + angDiff(a,b)*ALPHA; }
function sinMap(deg){ return Math.sin((deg*Math.PI)/180); }
function handleOrient(e){
  const yaw180 = wrap180(typeof e.alpha==='number'? e.alpha:0);
  const pitch = typeof e.beta==='number'? e.beta:0;
  const roll  = typeof e.gamma==='number'? e.gamma:0;

  state.yaw   = smoothAngles(yaw180, state.yaw);
  state.pitch = smoothAngles(pitch, state.pitch);
  state.roll  = smoothAngles(roll, state.roll);

  const sy = sinMap(state.yaw);
  const sp = sinMap(state.pitch) * PITCH_SENS;
  const sr = sinMap(state.roll);

  if (therOsc && audioCtx){
    const base = 440, range = 880;
    const f = base + (sy*0.4 + sp*0.6)*range;
    therOsc.frequency.setTargetAtTime(Math.max(80, Math.min(2000, f)), audioCtx.currentTime, 0.03);
  }
  orient.textContent = `Yaw ${state.yaw.toFixed(0)}° / Pitch ${state.pitch.toFixed(0)}° / Roll ${state.roll.toFixed(0)}°`;
}
function handleMotion(e){
  const a = e.accelerationIncludingGravity; if(!a) return;
  const mag = Math.hypot(a.x||0,a.y||0,a.z||0);
  const now = performance.now();
  if(mag > 28 && (!window._lastShake || now-window._lastShake>600)){ window._lastShake = now; playChime(); }
}
async function enableSensors(){
  try{
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
      await DeviceMotionEvent.requestPermission().catch(()=>{});
    }
  }catch(e){}
  addEventListener('deviceorientation', handleOrient, true);
  addEventListener('devicemotion', handleMotion, true);
}
enableSensors();

// ===== WAV Recorder via AudioWorklet =====
let recNode, recBuffers=[], recSampleRate=48000, recording=false, timer=null, recStart=0;
async function initRecorder(){
  const code = `
    class MixTap extends AudioWorkletProcessor{
      process(inputs, outputs, params){
        const ch0 = inputs[0]?.[0];
        if (ch0){ this.port.postMessage(ch0); }
        return true;
      }
    }
    registerProcessor('mix-tap', MixTap);
  `;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  await audioCtx.audioWorklet.addModule(url);
  recNode = new AudioWorkletNode(audioCtx, 'mix-tap');
  const tap = audioCtx.createGain(); tap.gain.value = 1.0;
  masterG.connect(tap).connect(recNode);
  recNode.port.onmessage = (e)=>{ if(recording) recBuffers.push(new Float32Array(e.data)); };
}
function concatFloat32(arrs){ let n=0; arrs.forEach(a=>n+=a.length); const out=new Float32Array(n); let o=0; for(const a of arrs){ out.set(a,o); o+=a.length; } return out; }
function f32ToPCM16(f32){ const dv=new DataView(new ArrayBuffer(f32.length*2)); for(let i=0;i<f32.length;i++){ let s=Math.max(-1,Math.min(1,f32[i])); dv.setInt16(i*2, s<0? s*0x8000 : s*0x7FFF, true);} return dv; }
function muxWAV(pcm16, sr){ const buf=new ArrayBuffer(44+pcm16.byteLength); const v=new DataView(buf);
  function ws(o,s){ for(let i=0;i<s.length;i++) v.setUint8(o+i, s.charCodeAt(i)); }
  ws(0,'RIFF'); v.setUint32(4,36+pcm16.byteLength,true); ws(8,'WAVE'); ws(12,'fmt ');
  v.setUint32(16,16,true); v.setUint16(20,1,true); v.setUint16(22,1,true); v.setUint32(24,sr,true);
  v.setUint32(28,sr*2,true); v.setUint16(32,2,true); v.setUint16(34,16,true); ws(36,'data'); v.setUint32(40,pcm16.byteLength,true);
  return new Blob([v, pcm16], {type:'audio/wav'});
}
function startRec(){
  if (!audioCtx) return;
  recBuffers.length=0; recSampleRate = audioCtx.sampleRate; recording=true;
  rec.disabled=true; recStop.disabled=false;
  recStart = performance.now();
  timer = setInterval(()=>{ const s=Math.floor((performance.now()-recStart)/1000); const m=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); rectime.textContent=m+':'+ss; }, 500);
}
function stopRec(){
  recording=false; rec.disabled=false; recStop.disabled=true; clearInterval(timer); rectime.textContent='00:00';
  const mono = concatFloat32(recBuffers); const pcm16 = f32ToPCM16(mono); const wav = muxWAV(pcm16, recSampleRate);
  const a=document.createElement('a'); const ts=new Date().toISOString().replace(/[:.]/g,'-'); a.href=URL.createObjectURL(wav); a.download='AERIAL_v8_2_'+ts+'.wav'; a.click();
}

// ===== Burst visual (subtle) =====
const cvs = document.getElementById('burst'), g = cvs.getContext('2d'); let burstT=0;
function fit(){ const r=window.devicePixelRatio||1; cvs.width=innerWidth*r; cvs.height=innerHeight*r; cvs.style.width=innerWidth+'px'; cvs.style.height=innerHeight+'px'; }
addEventListener('resize', fit); fit();
function burst(){ burstT = performance.now(); }
(function loop(){
  requestAnimationFrame(loop);
  const now = performance.now();
  const r=window.devicePixelRatio||1; g.setTransform(r,0,0,r,0,0);
  g.clearRect(0,0,cvs.width,cvs.height);
  if(!burstT) return;
  const dt = (now - burstT)/1000;
  if (dt>0.9){ burstT=0; return; }
  const cx = innerWidth/2, cy = innerHeight*0.25;
  const rad = 30 + dt*420;
  const a = Math.max(0, 1 - dt*1.2);
  g.beginPath(); g.arc(cx, cy, rad, 0, Math.PI*2);
  g.strokeStyle = 'rgba(255,255,255,'+a.toFixed(3)+')';
  g.lineWidth = 2 + 6*(1-a); g.stroke();
})();

// ===== UI wiring =====
const startBtn = document.getElementById('start'), stopBtn=document.getElementById('stop');
const chimeBtn = document.getElementById('chime');
const master = document.getElementById('master');
const bpmEl = document.getElementById('bpm');
const rec = document.getElementById('rec'), recStop=document.getElementById('recStop'), rectime=document.getElementById('rectime'), orient=document.getElementById('orient');

startBtn.onclick = async ()=>{ await start(); schedule(); };
stopBtn.onclick = async ()=>{ await stop(); };
chimeBtn.onclick = async ()=>{ await playChime(); };

master.oninput = e=>{ if(masterG) masterG.gain.value = parseInt(e.target.value,10)/100; };
</script>
</body></html>
