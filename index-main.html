<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AERIAL — Ambient Weather Music</title>
  <meta name="theme-color" content="#0e0f12" />
  <link rel="manifest" href="manifest.json?v=3" />
  <link rel="icon" href="icon-192.png" sizes="192x192" />
  <style>
    :root { --bg:#0e0f12; --fg:#e6e6e6; --muted:#8a8f98; --accent:#8fd3ff; --ok:#6ee7b7; --warn:#fbbf24; --err:#f87171; }
    *{box-sizing:border-box} html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, Helvetica, Arial, sans-serif;}
    .wrap{display:flex;flex-direction:column;min-height:100%}
    header{padding:14px 18px;display:flex;align-items:center;gap:12px;border-bottom:1px solid #1c1f24}
    header .dot{width:10px;height:10px;border-radius:50%;background:var(--accent);box-shadow:0 0 12px var(--accent)}
    header h1{font-size:18px;margin:0;letter-spacing:.3px}
    header .ver{margin-left:auto;font-size:12px;color:var(--muted)}
    main{flex:1;display:grid;grid-template-columns:1fr 320px;gap:16px;padding:16px}
    @media (max-width:900px){ main{ grid-template-columns:1fr; } }
    #stage{position:relative;border-radius:16px;overflow:hidden;background: radial-gradient(1200px 800px at 50% 60%, #1a1f29, #0b0c0f); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03), 0 10px 40px rgba(0,0,0,.6);}
    #canvas{width:100%;height:100%;display:block}
    .glass{position:absolute;inset:0;pointer-events:none;background: radial-gradient(600px 400px at var(--x,50%) var(--y,50%), rgba(143,211,255,0.12), transparent 60%);transition: background-position .2s ease;}
    aside{display:flex;flex-direction:column;gap:12px}
    .card{background:#12151b;border:1px solid #1f242c;border-radius:14px;padding:14px}
    .card h2{font-size:14px;letter-spacing:.4px;margin:0 0 8px;color:#b7c0cc}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button,.pill{background:#0f1320;color:#cfe7ff;border:1px solid #253043;padding:10px 12px;border-radius:12px;font-size:14px;cursor:pointer;transition:transform .05s ease, background .2s ease, border-color .2s ease;user-select:none;-webkit-tap-highlight-color: transparent;}
    button:hover{transform: translateY(-1px)} button:active{transform: translateY(1px) scale(.99)}
    .pill{display:inline-flex;align-items:center;gap:8px}
    .muted{color:var(--muted);font-size:12px}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    .start{font-weight:600;background:#11263a;border-color:#224561}
    .stop{background:#1b1420;border-color:#44234f;color:#ffd6ff}
    footer{padding:10px 16px;border-top:1px solid #1c1f24;font-size:12px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="dot"></div>
    <h1>AERIAL</h1>
    <div class="ver">v3 • Ambient Weather Music</div>
  </header>
  <main>
    <section id="stage">
      <canvas id="canvas"></canvas>
      <div class="glass"></div>
    </section>
    <aside>
      <div class="card">
        <h2>Controls</h2>
        <div class="row">
          <button id="btnStart" class="start">▶ Start</button>
          <button id="btnStop" class="stop" disabled>⏹ Stop</button>
          <button id="btnMute" class="pill" disabled>🔇 Mute</button>
          <button id="btnPhones" class="pill">🎧 Headphones</button>
          <button id="btnPerm" class="pill">⚙️ Sensors</button>
        </div>
        <div class="muted" style="margin-top:8px;">
          初回は <b>Start</b> を押してオーディオを有効化。<br/>
          *環境音(マイク)と生成音を意図的にブレンドします。音量に注意。
        </div>
      </div>
      <div class="card">
        <h2>Sensors</h2>
        <div class="row">
          <span class="pill"><span class="k">Noise</span><span class="v" id="noise">--.- dB</span></span>
          <span class="pill"><span class="k">Light</span><span class="v" id="light">-- lux</span></span>
          <span class="pill"><span class="k">Motion</span><span class="v" id="motion">--.--</span></span>
          <span class="pill"><span class="k">Hour</span><span class="v" id="hour">--:--</span></span>
          <span class="pill"><span class="k">Lat/Lon</span><span class="v" id="latlon">--</span></span>
        </div>
        <div class="muted" style="margin-top:6px;">端末により照度センサーは非対応のことがあります。</div>
      </div>
      <div class="card">
        <h2>About</h2>
        <div class="muted">
          マイク・光・動き・時間・場所を音のパラメータへマッピングし、
          その場だけのアンビエントを合成する作品。<br/>
          推奨：<b>ヘッドフォン</b>／音量注意。
        </div>
      </div>
    </aside>
  </main>
  <footer>
    <span>© AERIAL · PWA</span><span>·</span><span id="status" class="muted">Idle</span>
  </footer>
</div>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js?v=3').catch(console.warn);
  });
}

const els = {
  canvas: document.getElementById('canvas'),
  glass: document.querySelector('.glass'),
  noise: document.getElementById('noise'),
  light: document.getElementById('light'),
  motion: document.getElementById('motion'),
  hour: document.getElementById('hour'),
  latlon: document.getElementById('latlon'),
  status: document.getElementById('status'),
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  btnMute: document.getElementById('btnMute'),
  btnPhones: document.getElementById('btnPhones'),
  btnPerm: document.getElementById('btnPerm'),
};

let audioCtx, master, reverb, padGain, micGain, analyser, micAnalyser;
let micStream = null;
let running = false;
let muted = false;
let rafId;
let lux = NaN;
let motionAmt = 0;
let padNodes = [];
let lfo, lfoGain, filter;

function dbFromRMS(rms){ const ref = 1.0; const val = Math.max(rms, 1e-8); return 20 * Math.log10(val / ref); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

async function setupAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  master = audioCtx.createGain(); master.gain.value = 0.9; master.connect(audioCtx.destination);
  reverb = audioCtx.createConvolver();
  reverb.buffer = makeImpulseResponse(audioCtx, 2.8, 6.0, true);
  const revGain = audioCtx.createGain(); revGain.gain.value = 0.25; revGain.connect(master);
  reverb.connect(revGain);

  filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 800;
  padGain = audioCtx.createGain(); padGain.gain.value = 0.2;
  padGain.connect(filter); filter.connect(reverb); filter.connect(master);

  lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0.1;
  lfoGain = audioCtx.createGain(); lfoGain.gain.value = 200;
  lfo.connect(lfoGain); lfoGain.connect(filter.frequency); lfo.start();

  const base = pickBaseHzByHour();
  const ratios = [1, 5/4, 3/2, 2];
  for (let r of ratios) {
    const o = audioCtx.createOscillator();
    o.type = 'sawtooth'; o.frequency.value = base * r;
    const vib = audioCtx.createOscillator(); vib.type='sine'; vib.frequency.value = 0.15 + Math.random()*0.1;
    const vibGain = audioCtx.createGain(); vibGain.gain.value = 1.5 + Math.random()*1;
    vib.connect(vibGain); vibGain.connect(o.frequency); vib.start();
    const g = audioCtx.createGain(); g.gain.value = 0.08; o.connect(g); g.connect(padGain); o.start();
    padNodes.push(o, vib, g);
  }

  const noise = audioCtx.createBufferSource(); noise.buffer = makeNoise(audioCtx,4);
  const nFilter = audioCtx.createBiquadFilter(); nFilter.type='highpass'; nFilter.frequency.value = 500;
  const nGain = audioCtx.createGain(); nGain.gain.value = 0.02;
  noise.loop = true; noise.connect(nFilter); nFilter.connect(nGain); nGain.connect(reverb); noise.start();

  try {
    micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: false } });
    const mic = audioCtx.createMediaStreamSource(micStream);
    micGain = audioCtx.createGain(); micGain.gain.value = 0.10;
    mic.connect(micGain); micGain.connect(reverb); micGain.connect(master);
    const split = audioCtx.createGain(); mic.connect(split);
    micAnalyser = audioCtx.createAnalyser(); micAnalyser.fftSize = 1024; split.connect(micAnalyser);
  } catch (e) { console.warn('Mic error', e); }
}

function makeImpulseResponse(ctx, duration=2, decay=3, reverse=false){
  const rate = ctx.sampleRate, length = rate*duration, impulse = ctx.createBuffer(2,length,rate);
  for (let ch=0; ch<2; ch++){ const data = impulse.getChannelData(ch);
    for (let i=0;i<length;i++){ const t = reverse ? (length - i) : i; data[i] = (Math.random()*2 - 1) * Math.pow(1 - t/length, decay); } }
  return impulse;
}
function makeNoise(ctx,duration=2){ const len=ctx.sampleRate*duration, b=ctx.createBuffer(1,len,ctx.sampleRate), d=b.getChannelData(0); for(let i=0;i<len;i++){ d[i]=Math.random()*2-1 } return b; }

function pickBaseHzByHour(){
  const h = new Date().getHours();
  els.hour.textContent = new Date().toTimeString().slice(0,5);
  if (h >= 5 && h < 11) return 196;
  if (h >= 11 && h < 17) return 220;
  if (h >= 17 && h < 22) return 174.61;
  return 155.56;
}

async function start() {
  if (running) return;
  els.status.textContent = 'Starting...';
  await setupAudio();
  running = true;
  els.btnStart.disabled = true; els.btnStop.disabled = false; els.btnMute.disabled = false;
  loop();
  getGeo();
  startLight();
  await ensureMotionPermission();
}

function stop(){
  running=false; els.btnStart.disabled=false; els.btnStop.disabled=true; els.btnMute.disabled=true;
  if (rafId) cancelAnimationFrame(rafId);
  if (audioCtx) audioCtx.suspend();
  els.status.textContent = 'Stopped';
}

function toggleMute(){ muted=!muted; if (master) master.gain.value = muted ? 0 : 0.9; els.btnMute.textContent = muted ? '🔈 Unmute' : '🔇 Mute'; }

async function ensureMotionPermission(){
  try {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      const s = await DeviceMotionEvent.requestPermission();
      console.log('Motion perm', s);
    }
  } catch(e){ console.warn(e); }
  window.addEventListener('devicemotion', (ev) => {
    const ax = ev.accelerationIncludingGravity?.x || 0;
    const ay = ev.accelerationIncludingGravity?.y || 0;
    const az = ev.accelerationIncludingGravity?.z || 0;
    const amt = Math.min(1, Math.sqrt(ax*ax + ay*ay + az*az) / 20);
    els.motion.textContent = amt.toFixed(2);
    motionAmt = amt;
  }, { passive:true });
}

async function startLight(){
  if ('AmbientLightSensor' in window) {
    try {
      const sensor = new AmbientLightSensor();
      sensor.addEventListener('reading', () => { lux = sensor.illuminance; els.light.textContent = lux.toFixed(0) + ' lux'; });
      sensor.addEventListener('error', (e) => console.log('ALS error', e));
      sensor.start(); return;
    } catch(e){ console.log('ALS not available', e); }
  }
  const h = new Date().getHours();
  lux = (h >= 7 && h <= 17) ? 500 : 50;
  els.light.textContent = Math.round(lux) + ' lux (est)';
}

async function getGeo(){
  if (!navigator.geolocation) return;
  navigator.geolocation.getCurrentPosition((pos)=>{
    const { latitude, longitude } = pos.coords;
    els.latlon.textContent = latitude.toFixed(4)+', '+longitude.toFixed(4);
  }, (err)=>{ els.latlon.textContent = 'denied'; }, { enableHighAccuracy:false, timeout:3000, maximumAge:600000 });
}

function loop(){
  rafId = requestAnimationFrame(loop);
  const ctx = els.canvas.getContext('2d');
  resizeCanvas(els.canvas);
  let level = 0.02;
  if (micAnalyser) {
    const arr = new Uint8Array(micAnalyser.fftSize/2);
    micAnalyser.getByteFrequencyData(arr);
    let sum=0; for (let i=0;i<arr.length;i++) sum += arr[i]*arr[i];
    const rms = Math.sqrt(sum / arr.length) / 255;
    level = rms;
    const db = dbFromRMS(rms * 0.8 + 0.2);
    els.noise.textContent = (db+90).toFixed(1) + ' dB';
    const tgtCut = clamp(300 + rms*4000 + (lux/1000)*800, 200, 6000);
    if (filter) filter.frequency.linearRampToValueAtTime(tgtCut, audioCtx.currentTime + 0.2);
    if (padGain) padGain.gain.linearRampToValueAtTime(0.12 + rms*0.18 + motionAmt*0.1, audioCtx.currentTime + 0.1);
    if (lfo) lfo.frequency.linearRampToValueAtTime(0.05 + motionAmt*0.6 + (lux>200?0.05:0), audioCtx.currentTime + 0.2);
  }
  drawBackground(ctx);
  drawParticles(ctx, level);
  document.onpointermove = (e)=>{
    const rect = els.canvas.getBoundingClientRect();
    const x = clamp((e.clientX - rect.left) / rect.width * 100, 0, 100);
    const y = clamp((e.clientY - rect.top) / rect.height * 100, 0, 100);
    document.querySelector('.glass').style.setProperty('--x', x+'%');
    document.querySelector('.glass').style.setProperty('--y', y+'%');
  };
  els.status.textContent = 'Running';
}

function drawBackground(ctx){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  const g = ctx.createRadialGradient(w*0.5, h*(0.55 + motionAmt*0.05), Math.min(w,h)*0.05, w*0.5, h*0.6, Math.max(w,h)*0.9);
  const c1 = `rgba(${30+lux*0.05|0}, ${50+lux*0.04|0}, ${80+lux*0.06|0}, 1)`;
  const c2 = `rgba(10,12,16,1)`;
  g.addColorStop(0, c1); g.addColorStop(1, c2);
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
}

let particles = [];
function drawParticles(ctx, energy){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  if (particles.length < 160) {
    for (let i=0;i<4;i++){
      particles.push({ x: Math.random()*w, y: Math.random()*h, vx: (Math.random()*2-1)*0.2, vy: (Math.random()*2-1)*0.2, a: Math.random()*2*Math.PI, r: 0.8+Math.random()*1.8 });
    }
  }
  for (let p of particles){
    p.vx += (Math.sin(p.a) * 0.002 + (Math.random()-0.5)*0.002) * (1+energy*12);
    p.vy += (Math.cos(p.a) * 0.002 + (Math.random()-0.5)*0.002) * (1+energy*12);
    p.x += p.vx; p.y += p.vy; p.a += 0.01 + energy*0.2;
    if (p.x<0) p.x=w; if (p.x>w) p.x=0; if (p.y<0) p.y=h; if (p.y>h) p.y=0;
    const alpha = 0.25 + energy*0.6;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r + energy*8, 0, Math.PI*2);
    ctx.fillStyle = `rgba(${140+lux*0.1|0}, ${200+lux*0.05|0}, ${255}, ${alpha})`;
    ctx.fill();
  }
}

function resizeCanvas(c){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const w = c.clientWidth || innerWidth-340, h = c.clientHeight || (innerHeight - 220);
  if (c.width !== Math.floor(w*dpr) || c.height !== Math.floor(h*dpr)) {
    c.width = Math.floor(w*dpr); c.height = Math.floor(h*dpr);
    const ctx = c.getContext('2d'); ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
}

els.btnStart.onclick = () => { audioCtx && audioCtx.state==='suspended' ? audioCtx.resume() : null; start(); };
els.btnStop.onclick = stop;
els.btnMute.onclick = toggleMute;
els.btnPhones.onclick = () => alert('ヘッドフォン推奨：マイクとスピーカーの回り込みを抑え、より良い音像になります。');
els.btnPerm.onclick = async () => { await ensureMotionPermission(); startLight(); getGeo(); };
</script>
</body>
</html>
