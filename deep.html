<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AERIAL — Deep Ambient Edition (v6)</title>
  <meta name="theme-color" content="#0e0f12" />
  <link rel="manifest" href="manifest.json?v=6" />
  <link rel="icon" href="icon-192.png" sizes="192x192" />
  <style>
    :root { --bg:#0e0f12; --fg:#e6e6e6; --muted:#8a8f98; --accent:#8fd3ff; }
    *{box-sizing:border-box} html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, Helvetica, Arial, sans-serif;}
    main{max-width:980px;margin:0 auto;padding:16px;display:grid;grid-template-columns:1.1fr .9fr; gap:16px}
    @media (max-width:920px){ main{ grid-template-columns: 1fr; } }
    .panel{background:#12151b;border:1px solid #1f242c;border-radius:14px;padding:14px}
    h1{font-size:18px;margin:0 0 12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    select,button,input[type=range]{background:#0f1320;color:#cfe7ff;border:1px solid #253043;padding:8px 10px;border-radius:10px;font-size:14px}
    .btn{cursor:pointer}
    .kv{display:inline-flex;gap:6px;align-items:center;background:#0f1320;border:1px solid #253043;padding:8px 10px;border-radius:12px;font-size:13px;margin:4px 4px 0 0}
    .muted{color:#8a8f98;font-size:12px}
    #log{font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; white-space:pre-wrap; max-height:180px; overflow:auto; background:#0f1320; border:1px solid #253043; padding:8px; border-radius:10px }
    #canvas{width:100%;height:260px;background: radial-gradient(800px 600px at 50% 60%, #1a1f29, #0b0c0f); border:1px solid #1f242c; border-radius:12px;}
    label{font-size:12px;color:#a7b2c0;margin-right:4px}
  </style>
</head>
<body>
<main>
  <section class="panel">
    <h1>Deep Ambient — 無拍の揺らぎ</h1>
    <canvas id="canvas"></canvas>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnStart">▶ Start</button>
      <button class="btn" id="btnStop" disabled>⏹ Stop</button>
      <button class="btn" id="btnUpdate">🔄 Force Reload</button>
      <span class="muted">（音量に注意・イヤホン推奨）</span>
    </div>
    <div class="row" style="margin-top:10px">
      <label>Depth</label><input id="depth" type="range" min="0" max="100" value="70"/>
      <label>Space</label><input id="space" type="range" min="0" max="100" value="65"/>
      <label>Brightness</label><input id="bright" type="range" min="0" max="100" value="45"/>
    </div>
    <div class="muted" style="margin-top:6px">鼓動やクリックは一切ありません。音は切らずに連続変化します。</div>
  </section>

  <section class="panel">
    <h1>Sensors</h1>
    <div class="row">
      <div class="kv">Noise <span id="noise">-- dB</span></div>
      <div class="kv">Light <span id="light">-- lux</span></div>
      <div class="kv">Motion <span id="motion">--</span></div>
      <div class="kv">Yaw <span id="yaw">--°</span></div>
      <div class="kv">Hour <span id="hour">--:--</span></div>
      <div class="kv">Lat/Lon <span id="latlon">--</span></div>
    </div>
    <div style="margin-top:10px"><div id="log"></div></div>
  </section>
</main>

<script>
// ---------- State & UI ----------
const els = {
  canvas: document.getElementById('canvas'),
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  btnUpdate: document.getElementById('btnUpdate'),
  depth: document.getElementById('depth'),
  space: document.getElementById('space'),
  bright: document.getElementById('bright'),
  noise: document.getElementById('noise'),
  light: document.getElementById('light'),
  motion: document.getElementById('motion'),
  yaw: document.getElementById('yaw'),
  hour: document.getElementById('hour'),
  latlon: document.getElementById('latlon'),
  log: document.getElementById('log'),
};
function log(s){ els.log.textContent = (new Date()).toLocaleTimeString() + '  ' + s + "\n" + els.log.textContent; }

// ---------- Audio Nodes (continuous) ----------
let audioCtx, master, reverb, padFilter, pad, droneLow, droneMid, noiseShimmer, noiseGain, lfo1, lfo2, lfo3;
let micAnalyser=null, running=false, wakeLock=null;
function setupAudio(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  master = audioCtx.createGain(); master.gain.value = 0.9; master.connect(audioCtx.destination);

  // Reverb (single instance, long tail)
  reverb = audioCtx.createConvolver();
  reverb.buffer = makeImpulseResponse(audioCtx, 6.0, 8.0, true);
  const revGain = audioCtx.createGain(); revGain.gain.value = (parseInt(els.space.value,10)/100) * 0.5;
  reverb.connect(revGain).connect(master);

  // Pad bus + filter
  padFilter = audioCtx.createBiquadFilter(); padFilter.type='lowpass'; padFilter.frequency.value = 1200;
  const padBus = audioCtx.createGain(); padBus.gain.value = 0.4;
  padBus.connect(padFilter); padFilter.connect(reverb); padFilter.connect(master);

  // Drone Low (sine) — continuous
  droneLow = audioCtx.createOscillator(); droneLow.type='sine';
  droneLow.frequency.value = pickBaseHzByHour()/2;
  const lowGain = audioCtx.createGain(); lowGain.gain.value = 0.18;
  droneLow.connect(lowGain).connect(padBus); droneLow.start();

  // Drone Mid (saw -> gentle via filter)
  droneMid = audioCtx.createOscillator(); droneMid.type='sawtooth';
  droneMid.frequency.value = pickBaseHzByHour();
  const midGain = audioCtx.createGain(); midGain.gain.value = 0.10; // soft
  droneMid.connect(midGain).connect(padBus); droneMid.start();

  // Pad shimmer (filtered noise, very low)
  noiseShimmer = audioCtx.createBufferSource(); noiseShimmer.buffer = makeNoise(audioCtx, 2.0, true);
  noiseShimmer.loop = true;
  noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0.04;
  const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 3000;
  noiseShimmer.connect(hp).connect(noiseGain).connect(reverb); noiseShimmer.start();

  // LFOs (very slow)
  lfo1 = audioCtx.createOscillator(); lfo1.type='sine'; lfo1.frequency.value = 0.03; // ~33s
  lfo2 = audioCtx.createOscillator(); lfo2.type='sine'; lfo2.frequency.value = 0.07; // ~14s
  lfo3 = audioCtx.createOscillator(); lfo3.type='sine'; lfo3.frequency.value = 0.11; // ~9s
  const l1g = audioCtx.createGain(); l1g.gain.value = 30; lfo1.connect(l1g).connect(padFilter.frequency);
  const l2g = audioCtx.createGain(); l2g.gain.value = 0.004; lfo2.connect(l2g).connect(droneLow.frequency);
  const l3g = audioCtx.createGain(); l3g.gain.value = 0.006; lfo3.connect(l3g).connect(droneMid.frequency);
  lfo1.start(); lfo2.start(); lfo3.start();

  // Depth slider controls
  els.depth.addEventListener('input', (e)=>{
    const v = e.target.value/100;
    lowGain.gain.setTargetAtTime(0.08 + v*0.24, audioCtx.currentTime, 0.2);
    midGain.gain.setTargetAtTime(0.05 + v*0.2, audioCtx.currentTime, 0.2);
  });
  els.space.addEventListener('input', (e)=>{
    const v = e.target.value/100;
    revGain.gain.setTargetAtTime(v*0.6, audioCtx.currentTime, 0.2);
  });
  els.bright.addEventListener('input', (e)=>{
    const v = e.target.value/100;
    padFilter.frequency.setTargetAtTime(400 + v*3200, audioCtx.currentTime, 0.25);
  });
}

// ---------- Smooth sensors (EMA) ----------
let ema = { lux: null, motion: null, noise: null, yaw: null };
function smooth(key, value, alpha=0.1){ if (ema[key]==null) ema[key]=value; else ema[key] = ema[key]*(1-alpha) + value*alpha; return ema[key]; }

// ---------- Sensors ----------
let lux=200, motionAmt=0, yaw=0;
async function ensureMotionPermission(){
  try{
    if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ await DeviceMotionEvent.requestPermission(); }
  }catch(e){}
  window.addEventListener('devicemotion', ev=>{
    const ax=ev.accelerationIncludingGravity?.x||0, ay=ev.accelerationIncludingGravity?.y||0, az=ev.accelerationIncludingGravity?.z||0;
    const m = Math.min(1, Math.sqrt(ax*ax+ay*ay+az*az)/18);
    motionAmt = smooth('motion', m, 0.06);
    els.motion.textContent = motionAmt.toFixed(2);
    // Map motion -> subtle depth & shimmer
    if (noiseGain) noiseGain.gain.setTargetAtTime(0.02 + motionAmt*0.06, audioCtx.currentTime, 0.3);
  }, {passive:true});
}
function startOrientation(){
  window.addEventListener('deviceorientation', ev=>{
    yaw = smooth('yaw', (ev.alpha||0)/360, 0.05);
    els.yaw.textContent = Math.round((yaw*360))+'°';
    // Map yaw -> stereo rotation (via small detune/phase)
    if (droneMid && audioCtx){
      const base = pickBaseHzByHour();
      const bend = (yaw-0.5)*0.6; // ±0.3 semitone approx
      const freq = base * Math.pow(2, bend/12);
      droneMid.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.3);
    }
  }, {passive:true});
}
async function startLight(){
  els.hour.textContent = new Date().toTimeString().slice(0,5);
  if ('AmbientLightSensor' in window){
    try{
      const sensor = new AmbientLightSensor();
      sensor.addEventListener('reading', ()=>{
        lux = smooth('lux', sensor.illuminance, 0.08);
        els.light.textContent = lux.toFixed(0)+' lux';
        if (padFilter && audioCtx){
          const b = parseInt(els.bright.value,10)/100;
          const target = 300 + b*2000 + Math.min(1200, lux*1.5);
          padFilter.frequency.setTargetAtTime(target, audioCtx.currentTime, 0.4);
        }
      });
      sensor.start(); return;
    }catch(e){}
  }
  const h = new Date().getHours(); lux = (h>=7 && h<=17) ? 500 : 50; els.light.textContent = Math.round(lux)+' lux(est)';
}
async function startGeo(){
  if (!navigator.geolocation) return;
  navigator.geolocation.getCurrentPosition(pos=>{
    const { latitude, longitude } = pos.coords;
    els.latlon.textContent = latitude.toFixed(3)+', '+longitude.toFixed(3);
    // map latitude to base pitch slight offset (±2 semitones)
    const off = ((Math.abs(latitude)%4)-2)/12;
    const base = pickBaseHzByHour();
    if (droneLow && droneMid){
      droneLow.frequency.setTargetAtTime(base/2 * Math.pow(2, off), audioCtx.currentTime, 1.0);
      droneMid.frequency.setTargetAtTime(base   * Math.pow(2, off*0.5), audioCtx.currentTime, 1.0);
    }
  }, _=>{ els.latlon.textContent='denied'; }, { enableHighAccuracy:false, timeout:3000, maximumAge:600000 });
}

// mic analysis only (200ms interval)
function startMicAnalysis(){
  if (!navigator.mediaDevices?.getUserMedia) return;
  const start = async ()=>{
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      if (!audioCtx) audioCtx = ctx;
      const src = ctx.createMediaStreamSource(stream);
      micAnalyser = ctx.createAnalyser(); micAnalyser.fftSize = 1024; src.connect(micAnalyser);
      setInterval(()=>{
        if (!micAnalyser) return;
        const arr = new Uint8Array(micAnalyser.fftSize/2);
        micAnalyser.getByteFrequencyData(arr);
        let sum=0; for (let i=0;i<arr.length;i++) sum+=arr[i]*arr[i];
        const rms = Math.sqrt(sum/arr.length)/255;
        const db = 20*Math.log10(Math.max(rms,1e-6));
        const sm = smooth('noise', rms, 0.08);
        els.noise.textContent = (db+90).toFixed(1)+' dB';
        // Map noise -> density (pad bus & reverb level slight change)
        if (audioCtx && reverb){
          const add = Math.min(0.25, sm*0.25);
          master.gain.setTargetAtTime(0.85 + add*0.2, audioCtx.currentTime, 0.4);
        }
      }, 200);
    }catch(e){ log('Mic error: '+e); }
  };
  start();
}

// ---------- Helpers ----------
function makeImpulseResponse(ctx, duration=4, decay=6, reverse=false){
  const rate = ctx.sampleRate, length = rate*duration, impulse = ctx.createBuffer(2,length,rate);
  for (let ch=0; ch<2; ch++){ const data = impulse.getChannelData(ch);
    for (let i=0;i<length;i++){ const t = reverse ? (length-i) : i; data[i]=(Math.random()*2-1)*Math.pow(1 - t/length, decay); } }
  return impulse;
}
function makeNoise(ctx,dur=2.0, loopChunk=false){
  const len=ctx.sampleRate*dur, b=ctx.createBuffer(1,len,ctx.sampleRate), d=b.getChannelData(0);
  let x=0; // simple pink-ish noise via filtered white
  for(let i=0;i<len;i++){ x = 0.98*x + (Math.random()*2-1)*0.02; d[i]=x; }
  return b;
}
function pickBaseHzByHour(){
  const h = new Date().getHours();
  if (h>=5 && h<11) return 196; // G3
  if (h>=11 && h<17) return 220; // A3
  if (h>=17 && h<22) return 174.61; // F3
  return 155.56; // D#3
}

// ---------- Visual (slow ripples) ----------
let particles=[];
function draw(){
  const c=els.canvas, ctx=c.getContext('2d');
  const dpr=Math.min(2, devicePixelRatio||1);
  const w=c.clientWidth, h=c.clientHeight;
  if (c.width!==Math.floor(w*dpr) || c.height!==Math.floor(h*dpr)){ c.width=Math.floor(w*dpr); c.height=Math.floor(h*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
  // background gradient
  const g=ctx.createRadialGradient(w*0.5, h*(0.55 + (motionAmt||0)*0.05), Math.min(w,h)*0.05, w*0.5, h*0.6, Math.max(w,h)*0.9);
  g.addColorStop(0, `rgba(${30+lux*0.05|0}, ${50+lux*0.04|0}, ${80+lux*0.06|0}, 1)`);
  g.addColorStop(1, 'rgba(10,12,16,1)');
  ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  // soft ripples
  if (particles.length<80){ for(let i=0;i<3;i++){ particles.push({x:Math.random()*w,y:Math.random()*h,r:4+Math.random()*10,a:Math.random()*2*Math.PI}); } }
  for (const p of particles){
    p.r += 0.1 + (motionAmt||0)*0.8;
    if (p.r>Math.max(w,h)*0.5){ p.r = 4; p.x=Math.random()*w; p.y=Math.random()*h; }
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    ctx.strokeStyle = `rgba(${140+lux*0.1|0}, ${200+lux*0.05|0}, 255, ${0.02 + (motionAmt||0)*0.08})`;
    ctx.lineWidth = 1 + (motionAmt||0)*2; ctx.stroke();
  }
  requestAnimationFrame(draw);
}

// ---------- Wake Lock ----------
async function requestWakeLock(){
  try{ if ('wakeLock' in navigator){ wakeLock = await navigator.wakeLock.request('screen'); } }catch(e){}
}

// ---------- Service Worker control ----------
if ('serviceWorker' in navigator){
  addEventListener('load', async ()=>{
    const reg = await navigator.serviceWorker.register('./sw.js?v=6');
    els.btnUpdate.onclick = async ()=>{ const r = await navigator.serviceWorker.getRegistration(); await r?.update(); r?.waiting?.postMessage('SKIP_WAITING'); if (!r?.waiting) location.reload(); };
  });
}

// ---------- Start/Stop ----------
els.btnStart.onclick = async ()=>{
  if (running) return;
  setupAudio();
  await ensureMotionPermission(); startOrientation(); await startLight(); await startGeo(); startMicAnalysis();
  requestWakeLock();
  running = true; els.btnStart.disabled=true; els.btnStop.disabled=false;
  draw();
  log('Started (v6 Deep Ambient)');
};
els.btnStop.onclick = ()=>{
  running=false; els.btnStart.disabled=false; els.btnStop.disabled=true;
  if (audioCtx) audioCtx.suspend();
  if (wakeLock){ try{ wakeLock.release(); }catch(e){} wakeLock=null; }
  log('Stopped');
};
</script>
</body>
</html>
